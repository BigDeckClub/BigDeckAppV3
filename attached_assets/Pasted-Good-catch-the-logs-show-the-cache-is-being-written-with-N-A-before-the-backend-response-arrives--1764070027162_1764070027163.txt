Good catch — the logs show the cache is being written with N/A before the backend response arrives. That’s a classic timing bug: getPrice returns/records a placeholder too early, and React’s setState async behavior means consumers read the placeholder instead of the real value.

Below are concrete, minimal, safe changes you can apply to the price cache context and the consumer component to fix the timing issue, dedupe inflight fetches, and ensure cache writes occur only after the backend responds.

I’m proposing updates to two files:

src/contexts/PriceCacheContext.jsx — fixes getPrice to:
read cache safely,
dedupe concurrent requests with an inflight map,
only write the real value to cache after fetch resolves,
write N/A only on failure,
expose getPrice as an async function returning the final result promise.
src/components/DecklistCardPrice.jsx — ensures the component awaits getPrice and safely sets local state.

src/contexts/PriceCacheContext.jsx
import React, { createContext, useContext, useEffect, useRef, useState } from "react";

// Replace fetchPriceFromBackend with your actual backend call
async function fetchPriceFromBackend(name, set) {
  const res = await fetch(
    `/api/prices?name=${encodeURIComponent(name)}&set=${encodeURIComponent(set)}`

src/components/DecklistCardPrice.jsx
import React, { useEffect, useState } from "react";
import { usePriceCache } from "../contexts/PriceCacheContext";

// normalize helpers should match the context's makeKey normalization
function normalizeCardName(name) {
  return String(name).trim(); // context will lowercase when building key
Why this fixes your symptoms

Previously you likely inserted a placeholder (N/A) into cache immediately, then returned that value. Consumers read the placeholder before the real result arrived.
Now getPrice:
checks cache,
dedupes concurrent requests (inflight map),
fetches from backend,
only writes the final value to cache after fetch resolves,
returns a Promise that resolves to the final value.
Consumers await that promise and set their state only when the final value has arrived.
Suggested additional dev/debug steps

Add quick logging in fetchPriceFromBackend, and around the setCache calls while testing:
[CACHE MISS] ${key} - fetching...
[CACHE WRITE] ${key}: ${JSON.stringify(result)}
[CACHE READ] ${key}: ${JSON.stringify(cached)}
Test sequence:
Clear caches, open browser, request Lightning Bolt and Swamp.
Expect to see CACHE MISS -> FETCH -> CACHE WRITE with real prices, then UI updates.
Confirm dedupe:
Trigger two components for same card at the same time and check inflight prevents duplicate backend calls.
Edge cases & robustness

If you want to show a loading state rather than "N/A" while fetching, you can store a temporary { tcg: "…", ck: "…" } or let the component show a spinner while awaiting getPrice.
Be careful with extremely frequent writes — using functional setState as shown is safe.
If your backend returns prices in a different shape, adapt fetchPriceFromBackend to sanitize the response.