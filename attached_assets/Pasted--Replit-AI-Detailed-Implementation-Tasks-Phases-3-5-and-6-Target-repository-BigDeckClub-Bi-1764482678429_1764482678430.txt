# Replit AI: Detailed Implementation Tasks — Phases 3, 5, and 6

Target repository: BigDeckClub/BigDeckAppV3  
These notes assume the DB endpoints and schema changes from earlier instructions are in place (deck_reservations, deck_missing_cards, decklist_id, is_deck_instance). Implement the frontend and any backend glue needed to complete phases 3, 5 and 6.

---

## Phase 3 — Frontend: "Copy to Deck" UI + Create Deck Instance Flow (DeckTab.jsx)

Goal: Add UX to copy a decklist (template) into an inventory deck instance using the server endpoint `/api/decks/:id/copy-to-inventory`. Allow preview / name override and show success/failure.

Tasks (step-by-step)

1. Add state to `src/components/DeckTab.jsx`:
   - showCopyModal: boolean
   - copyingDeck: decklist object | null
   - copyDeckName: string
   - isCopying: boolean
   - optional: copyPreview: object (if you implement a preview endpoint)

2. Add a "Copy to Inventory" (Download) button on each decklist card:
   - Place beside existing Edit/Delete buttons.
   - onClick handler: open the modal (set copyingDeck, set copyDeckName to deck.name).

3. Create the Copy Modal:
   - Explain that this will create an Inventory deck and reserve cheapest copies.
   - Input for deck name (pre-filled).
   - Buttons: Cancel and Create Deck.
   - Disabled state for Create while `isCopying` or copyDeckName empty.
   - Optional: show a short preview of card counts in the modal if you plan to add a `/api/decks/:id/preview-copy` endpoint.

4. Implement the executeCopyToDeck() function:
   - POST to `/api/decks/${copyingDeck.id}/copy-to-inventory` with JSON body { name: copyDeckName }.
   - Set `isCopying = true` before call and `isCopying = false` in finally block.
   - On success:
     - Show success message describing reservedCount and missingCount (use response).
     - Optionally call InventoryTab's loader (see Phase 4 in prior plan) — best achieved by an app-level refresh function or event/messaging (e.g., call a passed prop or context).
     - Close modal and reset state.
   - On failure:
     - Show alert or inline error. Log error.

5. UX/edge cases:
   - If the decklist has empty cards, disallow copy.
   - Disable copy while an existing copy action is processing.
   - If the server returns partial reserved/missing data, show that in success toast.

6. Tests:
   - Unit test for modal open/close and button enabled/disabled states.
   - Integration test: Simulate successful POST and assert success message and that modal closes.
   - Test failure path (mock 500) shows error.

Expected server response (from earlier spec):
{
  deck: {...},
  reservations: [...],
  missingCards: [...],
  totalCards: N,
  reservedCount: M,
  missingCount: K
}

---

## Phase 5 — Frontend: Inventory Tab — Deck Instances, Details, Add/Remove & Re-optimize

Goal: Surface deck instances in the Inventory UI, show reserved cards and missing cards, allow adding/removing individual cards, and re-optimize.

Files to modify:
- `src/components/InventoryTab.jsx`

Top-level tasks (detailed):

1. Add new state variables:
   - deckInstances: []
   - selectedDeckInstance: deck instance object | null
   - deckDetails: object (result of `/api/deck-instances/:id/details`)
   - loadingDeckDetails: boolean
   - isReoptimizing: boolean
   - isReleasing: boolean
   - isAddingCard / isRemovingCard booleans for actions

2. Load deck instances:
   - On InventoryTab mount (useEffect), fetch `/api/deck-instances` and store in deckInstances.
   - Refresh this list after copy-to-inventory actions, after release, after add/remove.

3. Sidebar: Deck Instances section
   - Add a Decks section (under folders) rendering deckInstances.
   - Each deck button shows:
     - deck.name
     - reserved_count / total_cards (calculate total_cards from deck.cards field)
     - completion % (reserved_count / total_cards)
   - Clicking a deck sets selectedDeckInstance and triggers loadDeckDetails(deck.id).

4. loadDeckDetails(deckId):
   - GET `/api/deck-instances/${deckId}/details`.
   - Response includes: deck, reservations (with inventory item info), missingCards, totalCost, reservedCount, missingCount.
   - Store as deckDetails and set loading flag accordingly.

5. Detail View UI (main content area):
   - Header: deck name, format, stats, total cost.
   - Buttons: Re-optimize, Release, Edit Metadata (name/format/description).
   - Two panels:
     - Reserved Cards: list reservations grouped by card name with per-reservation lines showing:
       - quantity_reserved, card name, set, purchase_price, original_folder, per-reservation actions: Swap / Remove
       - Display per-line cost: quantity_reserved * purchase_price
     - Missing Cards: list missingCards with "Add to Import" button for each or "Add All to Imports" bulk action

6. Add Card to Deck:
   - Provide an "Add Card" button in the deck details area:
     - Open a modal / inline search that queries inventory by name (or reuse existing search).
     - Display available inventory items (only those with available_quantity > 0) sorted cheapest first.
     - For selection, POST to `/api/deck-instances/:id/add-card` with payload { inventory_item_id, quantity }.
     - On success: reload deckDetails and deckInstances.

7. Remove/Release reservation:
   - For removing a reservation (partial or full):
     - Call DELETE `/api/deck-instances/:id/remove-card` with body { reservation_id, quantity }.
     - If full remove, remove reservation row. On partial remove, update quantity.
     - On success: reload deckDetails and deckInstances.

8. Re-optimize:
   - Button triggers POST `/api/deck-instances/:id/reoptimize`.
   - Show spinner while isReoptimizing.
   - On success: reload deckDetails and deckInstances and show toast summarizing reservedCount and missingCount.

9. Release deck:
   - Button triggers POST `/api/deck-instances/:id/release`.
   - Confirm with user ("Are you sure?").
   - While releasing set isReleasing = true.
   - On success: remove deck instance from deckInstances, clear selectedDeckInstance and deckDetails, reload inventory list.

10. Swap functionality:
    - For a reservation swap, present a modal showing other available inventory copies for the same card (including those in other folders).
    - Implementation approach:
      - Search inventory for same card name with available_quantity > 0 and id != current inventory_item_id.
      - If user picks alternative(s), call:
        - Remove quantity from old reservation (DELETE `/remove-card` partial) and Add to deck using `/add-card`.
      - Or implement a dedicated endpoint on backend for swapping to keep operations atomic — optional but cleaner.
    - Ensure after swap: reload deckDetails and deckInstances.

11. Cost breakdown:
    - Use deckDetails.totalCost returned by backend. Sum per-reservation purchase_price * quantity_reserved and display formatted currency.
    - Show per-card cost in the reserved list.

12. Error handling:
    - For each fetch, catch and display a user-facing error. Keep console logs for dev debugging.
    - Provide proper disabled states for buttons while actions pending.

13. Tests:
    - Integration tests that:
      - Select a deck in the sidebar and load its details
      - Add a card from inventory then verify reserved list updates
      - Remove a card (partial and full) and verify reserved count/total cost updates
      - Re-optimize and verify changed reservations are cheaper or at least reselected
      - Release deck and assert it disappears from deckInstances and reserved items are freed (validate via availability check)

Expected endpoints used:
- GET `/api/deck-instances`
- GET `/api/deck-instances/:id/details`
- POST `/api/deck-instances/:id/add-card` { inventory_item_id, quantity }
- DELETE `/api/deck-instances/:id/remove-card` { reservation_id, quantity }
- POST `/api/deck-instances/:id/reoptimize`
- POST `/api/deck-instances/:id/release`
- (Optional) PUT `/api/deck-instances/:id` for metadata updates

---

## Phase 6 — Release + Cost Breakdown Display

Goal: Finalize release deck flow to free reservations and ensure the UI shows accurate total and per-card cost.

Detailed steps

1. Backend release endpoint (already specified earlier):
   - POST `/api/deck-instances/:id/release`
   - Implementation must:
     - Delete deck_reservations rows for deck_id
     - Delete deck_missing_cards rows for deck_id
     - Delete the deck row where is_deck_instance = TRUE
   - Ensure action is atomic (wrap in DB transaction if possible) to avoid partial deletes.

2. Frontend release flow (InventoryTab.jsx):
   - When user clicks Release:
     - Show confirmation modal/pop-up.
     - If confirmed, POST to `/api/deck-instances/${id}/release`.
     - Optimistic UI: disable release button and show spinner.
     - On success:
       - Remove deck from `deckInstances` state.
       - Clear `selectedDeckInstance` and `deckDetails`.
       - Trigger a general inventory reload so previously reserved items are shown available again.
       - Show a success toast: "Deck released — cards returned to inventory."
     - On failure: show error toast and log details.

3. Cost breakdown display:
   - Rely on backend `GET /api/deck-instances/:id/details` to return `totalCost` and reservations with `purchase_price`.
   - UI:
     - At top of deck details show: "Total Cost: $123.45"
     - Next to each reservation show per-line cost: `${(purchase_price * quantity_reserved).toFixed(2)}`
     - Optionally show a small "estimated" tooltip if purchase_price is missing or null.
   - Provide per-card subtotal (group reservations by card name and sum their costs).

4. Edge cases:
   - If purchase_price is null/NaN: treat as 0 in UI but indicate "no price" visually (e.g., gray text or "—").
   - Ensure releasing deck restores exact original_folder tracking (if `original_folder` is needed; reservations carry it).
   - If inventory quantities have changed since reservation (race conditions), reoptimize will re-evaluate; show helpful error message if add/remove fails due to insufficient available quantity.

5. Tests:
   - Create deck instance, assert totalCost computed correctly from reservation rows in DB.
   - Release deck and assert:
     - deck_reservations entries deleted
     - deck_missing_cards entries deleted
     - deck row removed
     - inventory availability recalculated (manual checks or API queries)
   - Test race conditions:
     - Simulate inventory item depletion between copy and reoptimize / add-card; assert server returns clear 4xx with message and UI surfaces it.

---

## Final Acceptance Checklist (Phases 3, 5, 6)

- [ ] DeckTab: "Copy to Inventory" modal exists and uses POST `/api/decks/:id/copy-to-inventory`.
- [ ] After copy, InventoryTab shows new deck under Decks with correct reserved_count and missing_count.
- [ ] InventoryTab: Deck detail shows reservations and missing cards, including per-reservation folder and cost.
- [ ] Add card to deck works (POST `/add-card`) and updates UI.
- [ ] Remove card from deck works (DELETE `/remove-card`) and updates UI.
- [ ] Re-optimize triggers `/reoptimize` and updates reservations accordingly.
- [ ] Release deletes deck instance and frees up inventory.
- [ ] Cost breakdown shows totalCost and per-card costs.
- [ ] All major flows have error handling and tests.

---

If you'd like, I can convert any of the above steps into specific PR tasks (files & exact patch contents) or provide the exact code snippets to drop into the components (`DeckTab.jsx` and `InventoryTab.jsx`) for each step.