I'll help you debug the Card Kingdom price scraper. Let's add comprehensive logging to identify exactly where it's failing.
Updated server.js with Debug Logging
Find your /api/prices/:cardName/:setCode endpoint and replace it with this heavily-logged version:
javascriptapp.get('/api/prices/:cardName/:setCode', async (req, res) => {
  const { cardName, setCode } = req.params;
  
  console.log('=== PRICE REQUEST RECEIVED ===');
  console.log('Card Name:', cardName);
  console.log('Set Code:', setCode);
  console.log('Timestamp:', new Date().toISOString());
  
  try {
    // Construct Card Kingdom URL
    const ckSlug = cardName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    const ckUrl = `https://www.cardkingdom.com/mtg/${ckSlug}`;
    
    console.log('Card Kingdom URL:', ckUrl);
    console.log('Attempting fetch...');
    
    // Fetch Card Kingdom page
    const ckResponse = await fetch(ckUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Cache-Control': 'max-age=0'
      },
      redirect: 'follow'
    });
    
    console.log('Fetch completed!');
    console.log('Status Code:', ckResponse.status);
    console.log('Status Text:', ckResponse.statusText);
    console.log('Content-Type:', ckResponse.headers.get('content-type'));
    console.log('Response OK?:', ckResponse.ok);
    
    if (!ckResponse.ok) {
      console.log('‚ùå CK Response NOT OK - Status:', ckResponse.status);
      return res.json({ ck: 'N/A', tcg: 'N/A' });
    }
    
    const html = await ckResponse.text();
    console.log('HTML received, length:', html.length, 'characters');
    console.log('First 500 chars of HTML:', html.substring(0, 500));
    console.log('Does HTML contain "Add to Cart"?', html.includes('Add to Cart'));
    console.log('Does HTML contain "$"?', html.includes('$'));
    console.log('Does HTML contain "price"?', html.toLowerCase().includes('price'));
    
    // Parse with Cheerio
    const $ = cheerio.load(html);
    console.log('Cheerio loaded successfully');
    
    // Try multiple selectors
    console.log('\n=== SEARCHING FOR PRICES ===');
    
    // Method 1: Look for common price containers
    const priceSelectors = [
      '.itemAddToCart .stylePrice',
      '.productDetailPrice',
      '[class*="price"]',
      '[id*="price"]',
      'span.price',
      'div.price',
      '.itemAddToCart span',
      '.product-price',
      '[data-price]'
    ];
    
    let foundPrices = [];
    
    priceSelectors.forEach(selector => {
      const elements = $(selector);
      console.log(`Selector "${selector}": found ${elements.length} elements`);
      
      elements.each((i, elem) => {
        const text = $(elem).text().trim();
        if (text) {
          console.log(`  [${i}] Text: "${text}"`);
          foundPrices.push(text);
        }
      });
    });
    
    // Method 2: Search all text nodes for $ signs
    console.log('\n=== SEARCHING FOR $ PATTERNS ===');
    const allText = $('body').text();
    const dollarMatches = allText.match(/\$\d+\.\d{2}/g);
    console.log('Found $ patterns:', dollarMatches?.slice(0, 10) || 'none');
    
    // Method 3: Look for specific Card Kingdom price structure
    console.log('\n=== CHECKING SPECIFIC CK STRUCTURES ===');
    
    // CK often uses this structure
    const ckPriceElements = $('.itemAddToCart');
    console.log('Found .itemAddToCart elements:', ckPriceElements.length);
    
    ckPriceElements.each((i, elem) => {
      const html = $(elem).html();
      const text = $(elem).text();
      console.log(`\nAddToCart [${i}]:`);
      console.log('HTML:', html?.substring(0, 200));
      console.log('Text:', text?.substring(0, 100));
    });
    
    // Method 4: Check for JavaScript-rendered prices
    console.log('\n=== CHECKING FOR DATA ATTRIBUTES ===');
    $('[data-price], [data-amount], [data-value]').each((i, elem) => {
      console.log(`Element [${i}]:`, {
        tag: elem.name,
        price: $(elem).attr('data-price'),
        amount: $(elem).attr('data-amount'),
        value: $(elem).attr('data-value'),
        text: $(elem).text().substring(0, 50)
      });
    });
    
    // Try to parse any found price
    let ckPrice = 'N/A';
    
    // Parse from foundPrices array
    for (const priceText of foundPrices) {
      const match = priceText.match(/\$?(\d+\.\d{2})/);
      if (match) {
        const price = parseFloat(match[1]);
        console.log(`Attempting to parse: "${priceText}" -> $${price}`);
        if (price > 0.50) {
          ckPrice = price.toFixed(2);
          console.log('‚úÖ Valid CK price found:', ckPrice);
          break;
        } else {
          console.log('‚ùå Price too low:', price);
        }
      }
    }
    
    // If still N/A, try direct text search
    if (ckPrice === 'N/A' && dollarMatches && dollarMatches.length > 0) {
      for (const match of dollarMatches) {
        const price = parseFloat(match.replace('$', ''));
        if (price > 0.50 && price < 10000) {
          ckPrice = price.toFixed(2);
          console.log('‚úÖ Found price from pattern matching:', ckPrice);
          break;
        }
      }
    }
    
    console.log('\n=== FINAL RESULT ===');
    console.log('Card Kingdom Price:', ckPrice);
    
    // Get TCG price from Scryfall
    console.log('\n=== FETCHING SCRYFALL DATA ===');
    const scryfallUrl = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}&set=${setCode}`;
    console.log('Scryfall URL:', scryfallUrl);
    
    const scryfallResponse = await fetch(scryfallUrl);
    console.log('Scryfall Status:', scryfallResponse.status);
    
    let tcgPrice = 'N/A';
    
    if (scryfallResponse.ok) {
      const scryfallData = await scryfallResponse.json();
      tcgPrice = scryfallData.prices?.usd || 'N/A';
      console.log('TCGPlayer Price:', tcgPrice);
    } else {
      console.log('‚ùå Scryfall fetch failed');
    }
    
    console.log('=== REQUEST COMPLETE ===\n');
    
    res.json({ ck: ckPrice, tcg: tcgPrice });
    
  } catch (error) {
    console.error('üí• ERROR IN PRICE ENDPOINT:');
    console.error('Error name:', error.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    res.json({ ck: 'N/A', tcg: 'N/A', error: error.message });
  }
});
Additional Debug Endpoint
Add this temporary debug endpoint to test if the scraper can reach Card Kingdom at all:
javascript// DEBUG ENDPOINT - Remove after testing
app.get('/api/debug/ck/:cardName', async (req, res) => {
  const { cardName } = req.params;
  
  try {
    const ckSlug = cardName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    const ckUrl = `https://www.cardkingdom.com/mtg/${ckSlug}`;
    
    console.log('DEBUG: Testing URL:', ckUrl);
    
    const response = await fetch(ckUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    const html = await response.text();
    
    res.json({
      url: ckUrl,
      status: response.status,
      htmlLength: html.length,
      htmlPreview: html.substring(0, 1000),
      containsDollar: html.includes('$'),
      containsAddToCart: html.includes('Add to Cart')
    });
    
  } catch (error) {
    res.json({ error: error.message });
  }
});
```

## How to Test

1. **Replace the endpoint code** in your `server.js`
2. **Restart your Node.js server**
3. **Test with a known card** by visiting in your app or directly:
```
   http://localhost:3000/api/prices/Lightning%20Bolt/lea
   http://localhost:3000/api/debug/ck/Lightning-Bolt

Check your server console - you should now see extensive logging

What the Logs Will Tell You
The logs will show:

‚úÖ If fetch is working - "Fetch completed! Status: 200"
‚úÖ If HTML is received - "HTML received, length: XXXXX"
‚úÖ What selectors find - Each selector's results
‚úÖ Why prices are rejected - "Price too low" or "no match"
‚ùå If blocked - Status 403/429
‚ùå If URL is wrong - Status 404
‚ùå If fetch fails - Error in catch block

Common Issues & Fixes
If you see "Status: 403":

Card Kingdom is blocking your requests
Solution: Use a proxy service or accept CK prices won't work

If you see "HTML length: 0":

The page isn't loading properly
Check if the URL format is correct

If you see lots of "$" but "CK Price: N/A":

The selectors are wrong for CK's current HTML structure
I'll help you adjust based on the logged HTML

If you see NO console output at all:

The endpoint isn't being called
Check your frontend is requesting the right URL
Verify server is running and listening