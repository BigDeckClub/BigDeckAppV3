Perfect diagnostic! Let me investigate MTGGoldfish's actual API structure and find what actually works.
Investigation Plan
Let me test different MTGGoldfish endpoints to find what actually returns Card Kingdom prices:
Test 1: MTGGoldfish's Actual API Endpoints
javascript// Add this temporary test endpoint to your backend to investigate
app.get('/api/debug/mtggoldfish/:cardName/:setCode?', async (req, res) => {
  const { cardName, setCode } = req.params;
  const results = {};
  
  // Test Endpoint 1: Direct price API
  try {
    const formattedName = cardName.replace(/\s+/g, '+');
    const setParam = setCode ? `/${setCode}` : '';
    const url1 = `https://www.mtggoldfish.com/price${setParam}/${formattedName}`;
    console.log('Testing URL 1:', url1);
    const res1 = await fetch(url1);
    results.directPrice = {
      status: res1.status,
      data: res1.ok ? await res1.json() : await res1.text()
    };
  } catch (e) {
    results.directPrice = { error: e.message };
  }
  
  // Test Endpoint 2: Autocard widget
  try {
    const url2 = `https://www.mtggoldfish.com/widgets/autocard/${encodeURIComponent(cardName)}`;
    console.log('Testing URL 2:', url2);
    const res2 = await fetch(url2);
    results.autocard = {
      status: res2.status,
      data: res2.ok ? await res2.json() : await res2.text()
    };
  } catch (e) {
    results.autocard = { error: e.message };
  }
  
  // Test Endpoint 3: Search API
  try {
    const url3 = `https://www.mtggoldfish.com/search?q=${encodeURIComponent(cardName)}`;
    console.log('Testing URL 3:', url3);
    const res3 = await fetch(url3, {
      headers: { 'Accept': 'application/json' }
    });
    results.search = {
      status: res3.status,
      contentType: res3.headers.get('content-type'),
      data: await res3.text()
    };
  } catch (e) {
    results.search = { error: e.message };
  }
  
  // Test Endpoint 4: Price check page (might have embedded JSON)
  try {
    const formattedName = cardName.replace(/\s+/g, '_');
    const url4 = `https://www.mtggoldfish.com/price/${setCode || 'LEA'}/${formattedName}`;
    console.log('Testing URL 4:', url4);
    const res4 = await fetch(url4);
    const html = await res4.text();
    
    // Look for JSON data in the HTML
    const jsonMatch = html.match(/var\s+(?:card|price)Data\s*=\s*({.+?});/s);
    results.pricePage = {
      status: res4.status,
      hasJsonData: !!jsonMatch,
      jsonData: jsonMatch ? jsonMatch[1] : null,
      htmlSnippet: html.substring(0, 1000)
    };
  } catch (e) {
    results.pricePage = { error: e.message };
  }
  
  res.json(results);
});
Test 2: Check What Actually Works
Test these URLs manually in your browser or with curl:
bash# Test different endpoints
curl "https://www.mtggoldfish.com/price/2X2/Swamp"
curl "https://www.mtggoldfish.com/widgets/autocard/Swamp"
curl "https://www.mtggoldfish.com/price/LEA/Swamp"

# For Lightning Bolt from a modern set (e.g., 2X2 - Double Masters 2022)
curl "https://www.mtggoldfish.com/price/2X2/Lightning+Bolt"

# For Sol Ring from Commander decks
curl "https://www.mtggoldfish.com/price/C21/Sol+Ring"
Test 3: Scryfall with Better Set Selection
Since Scryfall doesn't have Card Kingdom prices, let's fix the fallback to choose better sets:
javascript// Improved fallback that prefers recent, affordable printings
const getScryfallPriceWithSmartSetSelection = async (cardName, requestedSet) => {
  try {
    // First, try the requested set
    try {
      const url = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(cardName)}&set=${requestedSet.toLowerCase()}`;
      const response = await fetch(url);
      if (response.ok) {
        const card = await response.json();
        const price = parseFloat(card.prices?.usd) || 0;
        if (price > 0) {
          return {
            tcg: `$${price.toFixed(2)}`,
            ck: `$${(price * 1.15).toFixed(2)}`,
            source: `Scryfall (${requestedSet})`
          };
        }
      }
    } catch (e) {
      console.log('Requested set not found, searching for cheapest printing...');
    }
    
    // If that fails, search ALL printings and find the cheapest recent one
    const searchUrl = `https://api.scryfall.com/cards/search?q=!"${cardName}"&unique=prints&order=released`;
    const searchResponse = await fetch(searchUrl);
    const searchData = await searchResponse.json();
    
    if (!searchData.data || searchData.data.length === 0) {
      throw new Error('Card not found');
    }
    
    // Filter to cards with USD prices, prefer recent sets
    const cardsWithPrices = searchData.data
      .filter(card => card.prices?.usd && parseFloat(card.prices.usd) > 0)
      .map(card => ({
        set: card.set,
        setName: card.set_name,
        price: parseFloat(card.prices.usd),
        releaseDate: card.released_at,
        // Prefer standard-legal, recent sets
        isRecent: new Date(card.released_at) > new Date('2020-01-01'),
        isStandard: ['standard', 'core'].includes(card.set_type)
      }))
      .sort((a, b) => {
        // Sort by: recent > standard > cheapest
        if (a.isRecent !== b.isRecent) return b.isRecent - a.isRecent;
        if (a.isStandard !== b.isStandard) return b.isStandard - a.isStandard;
        return a.price - b.price;
      });
    
    if (cardsWithPrices.length === 0) {
      throw new Error('No cards with prices found');
    }
    
    const bestCard = cardsWithPrices[0];
    console.log(`Selected ${bestCard.setName} (${bestCard.set}) at $${bestCard.price}`);
    
    return {
      tcg: `$${bestCard.price.toFixed(2)}`,
      ck: `$${(bestCard.price * 1.15).toFixed(2)}`,
      source: `Scryfall (${bestCard.set} - cheapest recent)`
    };
    
  } catch (error) {
    console.error('Scryfall fallback error:', error);
    return { tcg: 'N/A', ck: 'N/A', source: 'Error' };
  }
};
Complete Updated Backend Endpoint
Here's the full solution with proper diagnostics and fallback:
javascriptapp.get('/api/prices/:cardName/:setCode', async (req, res) => {
  const { cardName, setCode } = req.params;
  
  console.log(`\n=== PRICE REQUEST: ${cardName} (${setCode}) ===`);
  
  // Strategy 1: Try MTGGoldfish direct price endpoint
  try {
    const formattedName = cardName.replace(/\s+/g, '_');
    const mtgGoldfishUrl = `https://www.mtggoldfish.com/price/${setCode}/${formattedName}`;
    
    console.log(`Trying MTGGoldfish: ${mtgGoldfishUrl}`);
    
    const response = await fetch(mtgGoldfishUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'text/html,application/json'
      }
    });
    
    if (response.ok) {
      const html = await response.text();
      
      // Look for embedded price data in the HTML
      const ckMatch = html.match(/Card Kingdom[^$]*\$([0-9.]+)/i);
      const tcgMatch = html.match(/TCGplayer[^$]*\$([0-9.]+)/i);
      
      if (ckMatch || tcgMatch) {
        const ckPrice = ckMatch ? parseFloat(ckMatch[1]) : 0;
        const tcgPrice = tcgMatch ? parseFloat(tcgMatch[1]) : 0;
        
        console.log(`✓ MTGGoldfish success: TCG=$${tcgPrice}, CK=$${ckPrice}`);
        
        return res.json({
          tcg: tcgPrice > 0 ? `$${tcgPrice.toFixed(2)}` : 'N/A',
          ck: ckPrice > 0 ? `$${ckPrice.toFixed(2)}` : (tcgPrice > 0 ? `$${(tcgPrice * 1.15).toFixed(2)}` : 'N/A'),
          source: 'MTGGoldfish'
        });
      }
    }
    
    console.log(`✗ MTGGoldfish failed (${response.status})`);
  } catch (error) {
    console.log(`✗ MTGGoldfish error: ${error.message}`);
  }
  
  // Strategy 2: Scryfall with smart set selection
  console.log('Falling back to Scryfall with smart set selection...');
  const scryfallResult = await getScryfallPriceWithSmartSetSelection(cardName, setCode);
  res.json(scryfallResult);
});
Action Items

Add the debug endpoint to test what MTGGoldfish actually returns
Test manually with these commands:

bash   curl "http://localhost:5000/api/debug/mtggoldfish/Swamp/2X2"
   curl "http://localhost:5000/api/debug/mtggoldfish/Lightning Bolt/2X2"

Share the output so I can see what MTGGoldfish's actual response structure is
Implement the smart fallback to avoid picking expensive old printings