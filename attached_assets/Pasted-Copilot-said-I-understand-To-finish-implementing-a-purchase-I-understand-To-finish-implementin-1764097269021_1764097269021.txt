Copilot said: I understand! To finish implementing a **purchase
I understand! To finish implementing a purchase history tracking system for the MTG Card Manager application in server.js, here are the detailed steps and instructions for Replit AI to follow:

1. Create a purchase_history Table
The purchase_history table will track every card purchase event independently, linking purchases by card_id or container_id where appropriate.

SQL Table Schema:
SQL
CREATE TABLE IF NOT EXISTS purchase_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    card_id INTEGER, -- Foreign key to cards (optional, NULL if container-level entry)
    container_id INTEGER, -- Foreign key to containers (optional, NULL for inventory cards)
    purchase_date TEXT NOT NULL, -- ISO 8601 DateTime string, e.g., "2023-05-02T14:30:00Z"
    purchase_price REAL NOT NULL, -- Purchase price (e.g., 2.50)
    quantity INTEGER DEFAULT 1, -- Quantity of cards purchased
    FOREIGN KEY(card_id) REFERENCES cards(id),
    FOREIGN KEY(container_id) REFERENCES containers(id)
);
2. Record Purchases in purchase_history
Whenever cards or containers are added or sold, create a corresponding entry in the purchase_history table.

When Cards are Added to Inventory:
For each card added to inventory via addInventoryItem:
Insert a new record into purchase_history.
Updated addInventoryItem Function Example:

JavaScript
const addInventoryItem = async (item) => {
    try {
        const response = await fetch(`${API_BASE}/inventory`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(item),
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        // Insert purchase record for each card added to inventory
        const purchaseDate = new Date().toISOString();
        const purchasePrice = item.purchase_price || 0;
        const purchaseQuantity = item.quantity || 1;

        db.run(`
            INSERT INTO purchase_history (card_id, purchase_date, purchase_price, quantity)
            VALUES (?, ?, ?, ?)`,
            [item.id, purchaseDate, purchasePrice, purchaseQuantity],
            (err) => {
                if (err) {
                    console.error("[DEBUG] Failed to record purchase:", err);
                } else {
                    console.log("[DEBUG] Purchase successfully recorded.");
                }
            }
        );

        await loadInventory(); // Refresh inventory table in the UI
        setSuccessMessage("Card added successfully!");
        setTimeout(() => setSuccessMessage(""), 3000);
        return true;
    } catch (error) {
        setSuccessMessage("Error adding card: " + error.message);
        setTimeout(() => setSuccessMessage(""), 3000);
        return false;
    }
};
When Cards Are Moved to Containers:
Copy the corresponding inventory card_id purchase records into the container.
Card-to-Container Movement Example SQL:

SQL
INSERT INTO purchase_history (container_id, purchase_date, purchase_price, quantity)
SELECT ?, purchase_date, purchase_price, quantity
FROM purchase_history
WHERE card_id = ?;
Update the backend handler for moving inventory cards to containers:

JavaScript
app.post('/api/containers/:containerId/add-card', (req, res) => {
    const { containerId } = req.params;
    const { cardId, quantity } = req.body;

    const purchaseDate = new Date().toISOString();

    db.run(`
        INSERT INTO purchase_history (container_id, purchase_date, purchase_price, quantity)
        SELECT ?, purchase_date, purchase_price, ?
        FROM purchase_history WHERE card_id = ?
    `, [containerId, quantity, cardId], function(err) {
        if (err) {
            console.error("[DEBUG] Failed to log container purchase in history:", err);
            res.status(500).send({ error: "Failed to update purchase history." });
            return;
        }
        res.sendStatus(200); // Success
    });
});
When Containers Are Sold:
Create a new purchase history entry with the total aggregated purchase price for that containerâ€™s cards.
Container Sale Example SQL:

SQL
SELECT SUM(purchase_price * quantity) AS total_cost
FROM purchase_history
WHERE container_id = ?;
Log container sales:

JavaScript
app.post('/api/containers/sell', (req, res) => {
    const { containerId, salePrice } = req.body;

    const query = `
        SELECT SUM(purchase_price * quantity) AS total_cost
        FROM purchase_history
        WHERE container_id = ?;
    `;

    db.get(query, [containerId], (err, row) => {
        if (err) {
            console.error("[DEBUG] Failed to fetch container total cost:", err);
            res.status(500).send({ error: "Failed to calculate total cost." });
            return;
        }

        const totalCost = row.total_cost || 0;

        // Sale logic...
        console.log(`[DEBUG] Container sold. Cost: ${totalCost}, Sale Price: ${salePrice}`);
        res.status(200).send({ cost: totalCost, price: salePrice });
    });
});
3. Update Analytics Calculations
Analytics calculations will now sum purchase amounts from the purchase_history table, filtered by purchase_date.

SQL to Calculate Purchases in Last 60 Days:
SQL
SELECT SUM(purchase_price * quantity) AS total_spent
FROM purchase_history
WHERE purchase_date >= datetime('now', '-60 days');
Add this SQL directly into the route handler for analytics:

JavaScript
app.get('/api/analytics/total-purchases', (req, res) => {
    const query = `
        SELECT SUM(purchase_price * quantity) AS total_spent
        FROM purchase_history
        WHERE purchase_date >= datetime('now', '-60 days');
    `;

    db.get(query, (err, row) => {
        if (err) {
            console.error("[DEBUG] Failed to calculate total purchases:", err);
            res.status(500).send({ error: "Failed to calculate total purchases." });
            return;
        }

        const totalSpent = row.total_spent || 0;
        res.send({ totalSpent });
    });
});
4. Frontend Update: Fetch Analytics
Update the frontend to fetch and display updated analytics totals.

Add useEffect in AnalyticsTab:

JavaScript
useEffect(() => {
    const fetchTotalPurchases = async () => {
        try {
            const response = await fetch('/api/analytics/total-purchases');
            const data = await response.json();
            console.log("[DEBUG] Total purchases fetched:", data);
            setTotalPurchases(data.totalSpent || 0);
        } catch (err) {
            console.error("[DEBUG] Failed to fetch total purchases:", err);
        }
    };
    fetchTotalPurchases();
}, []);
Update the AnalyticsTab.jsx component:

JavaScript
return (
    <div className="analytics-card">
        <h2>Total Spent in Last 60 Days</h2>
        <p>${totalPurchases.toFixed(2)}</p>
    </div>
);
5. Test Thoroughly
Add Cards to Inventory:
Verify entries are logged in purchase_history.
Move Cards to a Container:
Confirm container-level purchases inherit from inventory.
Sell a Container:
Ensure combined purchase amounts are recorded and displayed correctly.
Analytics Tab:
Verify the total spent accurately reflects purchases from the last 60 days.
