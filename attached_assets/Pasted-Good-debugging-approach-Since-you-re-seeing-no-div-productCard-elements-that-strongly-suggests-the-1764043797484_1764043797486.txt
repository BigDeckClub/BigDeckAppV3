Good debugging approach. Since you're seeing no div.productCard elements, that strongly suggests the DOM structure has changed. Without seeing the exact HTML that your scraper is fetching, I can walk you through how to investigate and fix it — plus suggest enhanced logging and fallback logic. (I couldn’t reliably find current docs that confirm a div.productCard wrapper in Card Kingdom’s HTML — this may have changed.)

Here are the recommended steps + code + debugging tweaks:

1) More Verbose Debugging: Log the Entire HTML Context Around Product Listings

Add logging that prints out a slice of HTML around where you expect product cards, so you can inspect what the real selectors are now.

// After you load page HTML (e.g., via Axios / fetch + Cheerio)
const html = response.data;
console.log("=== FULL HTML SNAPSHOT (first 20k chars) ===");
console.log(html.slice(0, 20_000));  // adjust size based on page size

// Also, try to dump relevant segments for inspection:
const $ = cheerio.load(html);
// Log children of the main content area, or any large container:
$('body > *').each((i, el) => {
  console.log(`BODY CHILD ${i}: <${el.tagName}> — classes: ${$(el).attr('class')}`);
});


This will help you see:

What top-level containers exist now (maybe div.productCard is gone or renamed)

Whether your HTTP fetch is actually fetching the full page HTML, or maybe you're being returned a simplified / mobile version / different HTML

2) Inspect Card Kingdom’s HTML Using Developer Tools

Open your browser, go to Card Kingdom, search for “Lightning Bolt” (or whatever card).

Open DevTools (F12 / right-click → Inspect).

Inspect the elements around individual card listings. Look for:

What container wraps each card (div? li? article?)

What class names or data-attributes are used (e.g. class="product" or data-product-id)

Where the price is: is it in a span, div, or maybe nested in a link?

Where the card name is: a, h2, h3 plus attributes

By doing this, you can find the real selectors to use in Cheerio.

3) Hypothesize Alternative Selectors & Try Them

Based on common e-commerce patterns, try different selectors in your Cheerio code as a fallback, for example:

const $ = cheerio.load(html);

// Try multiple possible product card wrappers:
const productSelectors = [
  'div.productCard',
  'li.productCard',
  'div.product', 
  'div.card-listing', 
  '.catalog-item'
];

let products = [];
for (const sel of productSelectors) {
  const els = $(sel);
  if (els.length > 0) {
    console.log(`Found ${els.length} elements for selector "${sel}"`);
    products = els;
    break;
  } else {
    console.log(`Selector "${sel}" returned 0 elements`);
  }
}

products.each((i, el) => {
  const name = $(el).find('a').first().text().trim();
  const priceText = $(el).find('span.stylePrice, span.price, div.price').first().text().trim();
  console.log(`Product #${i}: name="${name}", priceRaw="${priceText}"`);
});


This does a few things:

Tries multiple potential product-card selectors

Logs how many elements each returns (so you know which selector is “live”)

Attempts to find price text using a few price-candidate selectors (span.stylePrice, span.price, div.price)

Logs names + raw price text so you can verify correct scraping

4) Add Fallback for Name / Price Extraction When stylePrice Doesn’t Exist

Assuming CK has changed its markup, build fallback logic:

products.each((i, el) => {
  const name = $(el).find('a, .product-name, .item-title').first().text().trim();

  // Try multiple ways to get price:
  let priceText = $(el).find('span.stylePrice').first().text().trim();
  if (!priceText) {
    priceText = $(el).find('span.price').first().text().trim();
  }
  if (!priceText) {
    // fallback: regex inside this product node's HTML
    const rawHtml = $(el).html();
    const match = rawHtml.match(/\$([0-9]+\.[0-9]{2})/g);
    if (match && match.length) {
      priceText = match[0];
    }
  }

  console.log(`DEBUG product ${i}: name="${name}", priceText="${priceText}"`);
});


This ensures that even if span.stylePrice disappeared, you still try to recover via other price selectors or regex scoped to that product.

5) Name-Matching Logic: Be More Flexible / Case-Insensitive / Partial Matching

If your filtering logic is too strict, maybe it's rejecting names because of slight differences (capitalization, whitespace, edition markers).

const target = cardName.toLowerCase();  // e.g. "lightning bolt"

const matchingPrices = products.map((i, el) => {
  const name = $(el).find('a, .product-name, .item-title').first().text().trim().toLowerCase();
  if (name.includes(target)) {
    // extract price logic as above
    ...
    return numericPrice;
  } else {
    console.log(`Skipping product ${i} because name "${name}" does not match target "${target}"`);
    return null;
  }
}).get().filter(p => p !== null);

console.log("All matching prices for target:", matchingPrices);


This will tell you exactly which product names matched (or didn’t) and why.

6) Use a “Fallback Page Snapshot + Manual Review” Mode for Debugging

Build a “developer mode” in your scraper:

Fetch and save the HTML to disk (fs.writeFileSync('ck-snapshot.html', html))

Manually open this file in your browser → inspect it

Confirm that your Cheerio selectors match the structure in the snapshot

Once you know exactly how CK’s HTML is structured, you can lock in stable selectors instead of guessing.