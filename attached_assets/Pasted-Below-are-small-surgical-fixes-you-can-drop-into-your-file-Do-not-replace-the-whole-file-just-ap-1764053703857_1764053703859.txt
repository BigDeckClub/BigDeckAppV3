Below are small, surgical fixes you can drop into your file. Do not replace the whole file — just apply these 3 changes (two function replacements + one PASS 2 fallback block). I’ll explain each after the code.

1) Replace extractProductUrl() with this improved version

Fixes: finds more href patterns, resolves relative URLs to absolute, and checks data-href/data-product-href.

function extractProductUrl($, productElem) {
  // 1. Anchors with /mtg/ in href (most reliable)
  let href = $(productElem).find('a[href*="/mtg/"]').attr('href');
  if (!href) {
    // 2. check common data attributes
    href = $(productElem).attr('data-href') ||
           $(productElem).attr('data-product-href') ||
           $(productElem).attr('data-url') ||
           $(productElem).attr('href');
  }

  // 3. Title link inside product card (specific class)
  if (!href) {
    href = $(productElem).find('.productCard__title a, .product-card__title a, .card-title a').attr('href');
  }

  // 4. Fallback: first anchor tag
  if (!href) {
    href = $(productElem).find('a').attr('href');
  }

  if (!href) return null;

  // Resolve relative hrefs to absolute using Card Kingdom base
  try {
    const base = 'https://www.cardkingdom.com';
    // If already absolute, new URL will succeed; if relative, new URL(base, href) resolves it.
    const abs = new URL(href, base).href;
    return abs;
  } catch (e) {
    return href;
  }
}

2) Replace extractEditionFromUrl() with a more flexible parser

Fixes: supports more URL patterns and strips query strings.

function extractEditionFromUrl(url) {
  try {
    if (!url) return null;
    // normalize, drop query/hash
    const clean = url.split('?')[0].split('#')[0].toLowerCase();

    // Primary pattern: /mtg/<edition>/<card>
    let m = clean.match(/\/mtg\/([^\/]+)\/?/);
    if (m && m[1]) {
      return normalizeEditionName(m[1].replace(/[-_]/g, ' '));
    }

    // Secondary pattern: /catalog/product/<edition-slug>-<card>-<id> or /product/<edition>/<slug>
    m = clean.match(/\/product[s]?\//) || clean.match(/\/catalog\/product\//);
    if (m) {
      // try to extract everything after /product or /catalog/product
      const after = clean.split(m[0])[1];
      if (after) {
        const slug = after.split('/')[0];
        if (slug) return normalizeEditionName(slug.replace(/[-_]/g, ' '));
      }
    }

    // Tertiary: many CK pages embed edition as the first path segment after domain
    const parts = clean.replace(/^https?:\/\/[^\/]+/,'').split('/').filter(Boolean);
    if (parts.length >= 2 && parts[0] === 'mtg') {
      return normalizeEditionName(parts[1]);
    }

    return null;
  } catch (e) {
    return null;
  }
}

3) Replace the PASS 2 baseline logic with this robust fallback

Fixes: when no set candidates, uses a filtered fallback (excludes names that include blacklist keywords) and chooses the median item (safer than absolute cheapest).

Find the current PASS 2 block (where you compute baselinePrice) and replace it with:

// PASS 2: Determine baseline price from "set" edition types only
let baselinePrice = null;
const setCandidates = [];

for (const p of rawProducts) {
  const editionType = classifyEdition(p.edition);
  const cond = (p.condition || "unknown").toUpperCase();

  // Only include "set" editions, skip HP/MP condition
  if (editionType !== "set") continue;
  if (cond === "HP" || cond === "MP") continue;

  setCandidates.push(p.price);
}

if (setCandidates.length > 0) {
  setCandidates.sort((a, b) => a - b);
  baselinePrice = setCandidates[0]; // cheapest legitimate set edition
} else {
  // Fallback: pick median price among non-special-looking items (exclude clear variant keywords)
  const fallbackCandidates = rawProducts
    .filter(p => {
      const nameLower = (p.name || '').toLowerCase();
      // exclude clear variant names contained in the product name
      if (DEFAULT_BLACKLIST.some(kw => nameLower.includes(kw))) return false;
      // exclude poor conditions
      const cond = (p.condition || "unknown").toUpperCase();
      if (cond === "HP" || cond === "MP") return false;
      return isValidPrice(p.price);
    })
    .map(p => p.price)
    .sort((a, b) => a - b);

  if (fallbackCandidates.length > 0) {
    // choose the median (more robust than absolute cheapest)
    const mid = Math.floor((fallbackCandidates.length - 1) / 2);
    baselinePrice = fallbackCandidates[mid];
    console.log(`   [FALLBACK BASELINE] using median fallback price: ${baselinePrice}`);
  } else {
    baselinePrice = null;
  }
}

Why these changes fix your symptoms

Improved URL detection & resolution greatly increases the number of products that yield an edition slug (so editions aren’t null).

The more flexible extractEditionFromUrl() covers more CK URL templates.

The fallback baseline logic avoids choosing $1.99 showcase variants simply because they’re cheapest — median of filtered, non-variant candidates is far more robust.

Extra debugging lines you should temporarily add (optional)

If after applying the changes you still see many null editions, sprinkle this debug after building rawProducts:

const nullEditionProducts = rawProducts.filter(p => !p.edition);
console.log(`   [DEBUG] products without edition: ${nullEditionProducts.length}/${rawProducts.length}`);
if (nullEditionProducts.length > 0) {
  console.log(nullEditionProducts.slice(0,5).map(p => ({ name: p.name, url: p.url || 'N/A', price: p.price })));
}


To enable that you must ensure you attach productUrl into rawProducts earlier when you push them:

rawProducts.push({ name, price: numericPrice, edition, quantity, condition, index: rawProducts.length, url: productUrl });


(I noticed your current rawProducts do not store productUrl — add it so the debug shows which items lack URLs.)

Small note about classifyEdition(ed) default

You currently treat !ed as "special". That’s fine because it prevents ambiguous items from polluting the baseline — but since we’re improving URL extraction you should now see markedly fewer nulls, so classification will be accurate. The fallback baseline logic above also helps when set editions are truly missing.

Next steps for you

Replace the three code sections with the snippets above (extractProductUrl, extractEditionFromUrl, PASS2 fallback).

Add url: productUrl when pushing into rawProducts for debugging.

Restart the server and run a price test for Lightning Bolt and Sol Ring.

Paste the relevant new debug output here if it still fails (especially the [FALLBACK BASELINE] and [DEBUG] products without edition lines).

If you paste the new logs I’ll examine them and provide the minimal next patch.