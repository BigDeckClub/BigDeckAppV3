Nice — you’ve fixed the parsing bug and narrowed the problem: showcase/variant listings are still being misclassified as normal because their product names don’t always contain the obvious keywords. Below I give a pragmatic, production-ready plan plus a drop-in JS classifier you can paste into your scraper to dramatically reduce false-positives. I also include extra heuristics and debugging tips so you can quickly tune the rules for edge cases.

Strategy (short)

Create a comprehensive blacklist of variant keywords (showcase, alternate, borderless, artist, etc.).

Create a whitelist of patterns that strongly indicate a normal printing (exact name-only, name + set code like (KLD) where KLD is a normal set code, name + set year, etc.).

Normalize product names (lowercase, remove punctuation/diacritics, collapse whitespace) before matching.

Use a priority ranking: return cheapest from normal category first; only use special if no normal exists.

Add logging of borderline matches so you can refine the lists quickly.

Key ideas / heuristics to catch implicit showcases

Many show-case/alt-art listings include keywords: showcase, alternate, alt, extended art, borderless, art series, variant, variant art, promo, foil, etched, collector, secret lair, special edition, premium, prerelease, judge promo, FNM, oversized, oversized card. Add these to the blacklist.

Some premium variants don't include those words. Use secondary signals:

If the product title contains artist name, artist series, or (artist) tokens, treat as special.

If the product name contains extra adjectives after the card name (e.g., lightning bolt — showcase frame), treat as special.

If the product title is exactly the card name (possibly with set code in parentheses or trailing set name), treat as normal.

If you can parse set codes enclosed in () and you have a maintained allowlist of common set codes (like M21, KLD, ICE, etc.), treat those as normal. If the parenthetical contains words instead of a short uppercase code, treat them as special.

Drop-in JS classifier (Cheerio-friendly)
// editionClassifier.js

const DEFAULT_BLACKLIST = [
  'showcase','show case','show-case','alternate art','alternate','alt-art','alt art','alt',
  'extended art','extended-art','extended','borderless','border-less','border less',
  'artist','art series','art-series','variant','variant art','premium',
  'secret lair','secret-lair','promo','judge promo','judge','fnm','f.n.m','prerelease',
  'foil','etched','etched foil','super foil','super-foil','foil stamped','holo','hyperfoil',
  'collector','collector edition','collector-edition','oversized','oversized card',
  'special edition','special-edition','limited edition','limited-edition'
];

// Common words that imply the token in parentheses is a set code if short/upper-case
const SET_CODE_CANDIDATE = /^[A-Z0-9]{2,5}$/;

// Useful normalization
function normalizeName(name) {
  return name
    .normalize('NFKD')              // remove diacritics
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/[\u2013\u2014–—]/g, '-') // normalize hyphens
    .replace(/[^a-z0-9\-\(\)\s]/g, ' ') // remove punctuation except () and hypens
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * Classify product variant.
 * Returns one of: 'normal', 'set', 'special', 'promo', 'foil', 'etched', 'premium'
 */
function classifyVariant(rawName, cardName /* lowercase */, options = {}) {
  const blacklist = options.blacklist || DEFAULT_BLACKLIST;
  const name = normalizeName(rawName);
  const target = cardName.toLowerCase().trim();

  // If name is exactly the card name or card name + set code in parentheses -> normal
  // e.g. "lightning bolt", "lightning bolt (kld)", "sol ring (m21)"
  // also allow "cardname - set" like "lightning bolt - kld" (after normalizing)
  const exactPatterns = [
    `^${escapeForRegex(target)}$`,
    `^${escapeForRegex(target)}\\s*\\(${SET_CODE_CANDIDATE.source}\\)$`,
    `^${escapeForRegex(target)}\\s*[-–—:]\\s*${SET_CODE_CANDIDATE.source}$`,
    `^${escapeForRegex(target)}\\s+${SET_CODE_CANDIDATE.source}$`
  ];
  for (const p of exactPatterns) {
    if (new RegExp(p).test(name.toUpperCase() === name ? name : name)) {
      // careful: pattern uses uppercase set code – we will test on original normalized tokens below
      // but quick exact-match catch:
      if (name === target || name.startsWith(target + ' (') || name.startsWith(target + ' -') || name.startsWith(target + ' ')) {
        return 'normal';
      }
    }
  }

  // If name starts exactly with the card name and the rest is a short set code -> normal
  // e.g. "lightning bolt (kld)" -> parentheses content uppercase short token => normal
  const parenMatch = rawName.match(/\(([^)]+)\)\s*$/);
  if (parenMatch) {
    const token = parenMatch[1].trim();
    if (SET_CODE_CANDIDATE.test(token.toUpperCase())) {
      // treat as set printing (non-premium)
      // But still check if token itself contains blacklisted words
      const tokLower = token.toLowerCase();
      if (!blacklist.some(b => tokLower.includes(b))) return 'set';
    }
  }

  // If there is any blacklisted keyword anywhere, classify as special/promo/foil
  for (const kw of blacklist) {
    if (name.includes(kw)) {
      if (kw.includes('foil')) return 'foil';
      if (kw.includes('etched')) return 'etched';
      if (kw.includes('promo') || kw.includes('judge') || kw.includes('fnm') || kw.includes('prerelease'))
        return 'promo';
      return 'special';
    }
  }

  // If the product title contains extra descriptive tokens after the card name (e.g. "lightning bolt - showcase frame"),
  // treat as 'special'. Use a heuristic: if name starts with cardName then has >= 3 extra words or punctuation tokens it's likely variant.
  if (name.startsWith(target)) {
    const tail = name.slice(target.length).trim();
    if (tail.length > 0) {
      // If tail includes punctuation or more than 2 words, suspect variant
      const words = tail.split(/\s+/).filter(Boolean);
      if (words.length >= 2 || /showcase|alternate|extended|borderless|artist|variant/.test(tail)) {
        return 'special';
      } else {
        // small tail like "(kld)" already handled; short single word tails could be set names -> treat as set
        if (SET_CODE_CANDIDATE.test(words[0].toUpperCase())) return 'set';
        // otherwise assume normal (e.g., "Lightning Bolt foil" would have been caught by blacklist)
      }
    }
  }

  // Default fallback: if the name exactly contains the card name somewhere, prefer normal
  if (name.includes(target)) return 'normal';

  // final fallback: unknown => premium
  return 'premium';
}

function escapeForRegex(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

module.exports = { classifyVariant, normalizeName };


How to use:

classifyVariant(productNameRaw, 'lightning bolt')

You’ll get 'normal', 'special', 'promo', 'foil', etc.

Then in the price resolver: first collect products classified as 'normal' or 'set' and pick min price from those. Only if none exist pick from 'special' or 'promo'.

Priority selection (example)
const PRIORITY = ['normal', 'set', 'special', 'foil', 'etched', 'promo', 'premium'];

function pickBestProduct(products, cardName) {
  // products: [{name, price}]
  products.forEach(p => {
    p.variant = classifyVariant(p.name, cardName);
    p.rank = PRIORITY.indexOf(p.variant);
    if (p.rank === -1) p.rank = PRIORITY.length;
  });

  products.sort((a,b) => a.rank - b.rank || a.price - b.price);
  return products[0] || null;
}

Logging & tuning

Log examples of products that are classified as 'normal' but have extra tokens — these are candidates for adding to the blacklist.

When you run the scraper in debug mode, print a sample of misclassified items and examine them to add keywords gradually.

Keep a small file of known exceptions you can treat specially (e.g., "sol ring (0408 - elven)" might be an artist series and should be special even if it lacks obvious tokens).

Extra signals (optional but powerful)

If you can access extra node fields from the product element, these signals help:

Product URL slug: often contains showcase or alt-art. Check el.find('a').attr('href').

Product image filename/alt text: sometimes alt text contains showcase.

Product badges: look for elements that say PROMO, LIMITED, PREORDER etc.

Compare to TCG mid price: extremely low or extremely different relative to market may indicate variant or error — but be careful, some showcase variants can be cheaper than standard.

Quick tests you should run

classifyVariant("Lightning Bolt", "lightning bolt") -> normal

classifyVariant("Lightning Bolt (KLD)", "lightning bolt") -> set

classifyVariant("Lightning Bolt - Showcase Frame", "lightning bolt") -> special

classifyVariant("Lightning Bolt (Artist Series)", "lightning bolt") -> special

classifyVariant("Sol Ring (0408 - Elven)", "sol ring") -> likely special with current rules; add "0408" pattern if needed

Final notes

No classifier will be perfect for every new special release; treat this as a tunable heuristic. With logging of ambiguous cases, you’ll rapidly achieve near-100% correct classification.

The safest UX: prefer normal always even if slightly more expensive. Users expect standard edition price unless explicitly requested otherwise.