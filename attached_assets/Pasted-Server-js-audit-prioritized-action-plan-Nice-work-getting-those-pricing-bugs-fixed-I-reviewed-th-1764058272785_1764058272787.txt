Server.js audit & prioritized action plan

Nice work getting those pricing bugs fixed. I reviewed the full server.js you linked and below is a practical, prioritized audit: issues found, risks, concrete fixes (code snippets you can drop in), test ideas, and long-term improvements (caching, monitoring, infra).

I’ll keep it actionable: short explanations + copy-pasteable code where helpful.

1) High-priority fixes (make these first)
A. Wrap multi-step DB updates in transactions (bug / correctness)

Why: /api/containers/:id/sell updates inventory for multiple cards then inserts sale and flips container active flag. If one query fails midway the DB will be inconsistent.

Fix: use a transaction (BEGIN / COMMIT / ROLLBACK).

app.post('/api/containers/:id/sell', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const { salePrice } = req.body;
    const containerResult = await client.query('SELECT cards FROM containers WHERE id = $1 FOR UPDATE', [req.params.id]);
    if (containerResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Container not found' });
    }
    const cards = containerResult.rows[0].cards;

    for (const card of cards) {
      await client.query(
        'UPDATE inventory SET quantity = quantity - $1 WHERE id = $2',
        [card.quantity, card.inventoryId]
      );
    }

    const saleResult = await client.query(
      'INSERT INTO sales (container_id, sale_price) VALUES ($1,$2) RETURNING *',
      [req.params.id, salePrice]
    );

    await client.query('UPDATE containers SET is_active = FALSE WHERE id = $1', [req.params.id]);

    await client.query('COMMIT');
    res.json(saleResult.rows[0]);
  } catch (err) {
    await client.query('ROLLBACK');
    console.error('Sell container error (tx):', err);
    res.status(500).json({ error: 'Failed to sell container' });
  } finally {
    client.release();
  }
});


Also add checks so quantity never goes negative; validate inventory exists.

B. Add fetch timeouts + retry/backoff (robustness)

Why: External fetches (Scryfall / Card Kingdom) can hang or be slow. Node now has fetch, but you need an AbortController and retry/backoff.

Snippet:

async function fetchWithTimeout(url, opts = {}, timeout = 8000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  try {
    const res = await fetch(url, { ...opts, signal: controller.signal });
    return res;
  } finally {
    clearTimeout(id);
  }
}


Use with simple retry:

async function fetchRetry(url, opts, retries = 2) {
  for (let i = 0; i <= retries; i++) {
    try {
      return await fetchWithTimeout(url, opts, 8000);
    } catch (e) {
      if (i === retries) throw e;
      await new Promise(r => setTimeout(r, 500 * (i + 1)));
    }
  }
}


Use fetchRetry for Scryfall/CK calls.

C. Avoid trusting HTML/JSON attributes blindly (safety)

Why: extractEditionFromHtml JSON.parse of data-react-props can throw or parse attacker-supplied content. You already try/catch, but be careful and sanitize before using as edition.

Recommendation: After parsing, validate the type and length:

if (props && typeof props === 'object') {
  const candidate = props.printed_set || props.edition || props.set;
  if (typeof candidate === 'string' && candidate.length < 150) {
    return normalizeEditionName(candidate);
  }
}

2) Medium priority (stability, maintainability)
A. Improve logs structure & sampling

Use log levels (debug, info, warn, error) instead of freeform console.log.

Consider structured logs (JSON) so you can parse edition strings easily.

Remove or gate extremely verbose logs behind a debug flag to avoid flooding Cloud logs.

Example:

const DEBUG = process.env.DEBUG === '1';
if (DEBUG) console.debug({event: 'ck_product', name: p.name, edition: p.edition, price: p.price});

B. Add rate limiting and request throttling (compliance & reliability)

Why: Scraping Card Kingdom at high frequency risks being blocked / causing service interruptions.

Add express rate limiting:

import rateLimit from 'express-rate-limit';

app.use('/api/prices', rateLimit({
  windowMs: 30 * 1000,
  max: 10, // tunable
  standardHeaders: true,
  legacyHeaders: false
}));


Also implement internal queueing if you perform parallel scrapes — cap concurrency.

C. Use helmet and security middlewares
import helmet from 'helmet';
app.use(helmet());


Also enable CORS only for known origins or use token-based auth if public.

D. Validate incoming request payloads (avoid malformed DB inserts)

Why: POST /api/inventory, /api/decklists, etc. accept JSON and then insert to DB.

Use a schema validator (Joi/Zod) to enforce types and lengths.

Example with Joi:

import Joi from 'joi';
const inventorySchema = Joi.object({
  cardName: Joi.string().min(1).max(255).required(),
  setCode: Joi.string().max(10).allow(null),
  quantity: Joi.number().integer().min(0).required(),
  tcgPrice: Joi.number().precision(2).allow(null),
  ckPrice: Joi.number().precision(2).allow(null)
});

E. Harden price parsing & canonicalization

Your extractPricesFromText regex is good but sometimes CK shows prices without dollar sign or with unicode. You already handle \u00A0. Consider adding support for numbers like 1.99 without $.

When comparing prices, treat 0/N/A robustly and log suspicious extremes.

Suggestion:

const re2 = /(?:\$)?([0-9]{1,3}(?:,[0-9]{3})*(?:\.[0-9]{2})?)/g;

3) Lower-priority improvements (nice to have)
A. Caching layer (performance + cost reduction)

Cache Scryfall/CK results for configurable TTL (e.g., 5–30 minutes).

Use Redis or in-memory LRU (for single worker).

Cache by normalized key: ${cardName}|${setCode}.

B. Expose metrics & health endpoints

/health returning basic OK + DB connectivity.

/metrics for Prometheus (use prom-client).

Track counts: price_requests_total, ck_scrapes_total, ck_scrape_errors.

C. Use typed SQL or migrations

Ensure DB has constraints, indexes (e.g., on inventory.name, containers.is_active, decklists.created_at).

Use migrations (Flyway/Knex/migrate) rather than ad-hoc SQL.

D. Graceful shutdown & pool cleanup

Handle SIGINT/SIGTERM, close pool:

process.on('SIGTERM', async () => {
  console.log('Shutting down...');
  await pool.end();
  process.exit(0);
});

4) Security & legal considerations (must-read)

Scraping Card Kingdom: be mindful of robots.txt and ToS. Scraping heavy can cause legal/anti-bot issues. Prefer official APIs when available.

Rate-limits / polite behavior: set user agent, delay between requests, and avoid parallel hammering.

Protect secrets: ensure DATABASE_URL and other secrets come from env and not checked into git.

SQL injection: you use parameterized queries which is good. Continue to avoid string concatenation.

5) Tests & CI (how to verify changes automatically)
Unit tests

Parsing/unit: test extractEditionFromUrl, extractEditionFromHtml, classifyVariantWithEdition, classifyVariantEnhanced on many real-world examples.

Price extraction: feed sample CK HTML fixtures and assert parsed products/prices.

Use Jest and fixtures:

__tests__/parsers.test.js with nock or local HTML files.

__tests__/classification.test.js to assert Sol Ring/Lightning Bolt behavior.

Integration tests

Mock Scryfall & CK endpoints with nock to simulate failures, slow responses, and different product name variants.

Test the /api/prices/:card/:set endpoint end-to-end.

Example test (Jest + nock):
import nock from 'nock';
test('price endpoint returns ck price', async () => {
  nock('https://api.scryfall.com').get(/cards\/named/).reply(200, { prices: { usd: "2.29" }});
  nock('https://www.cardkingdom.com').get(/catalog\/search/).reply(200, '<html>...mocked listings...</html>');
  const res = await request(app).get('/api/prices/Lightning%20Bolt/M11');
  expect(res.body.tcg).toBe('$2.29');
});

6) Concrete code patches & snippets (ready to drop in)
Graceful shutdown + pool config
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000
});
process.on('SIGINT', async () => {
  console.info('SIGINT received — closing DB pool');
  await pool.end();
  process.exit(0);
});

Health endpoint
app.get('/health', async (req, res) => {
  try {
    await pool.query('SELECT 1');
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ ok: false });
  }
});

7) Edge cases to watch & test for

CK adds new variant naming conventions (e.g., translations, abbreviations) — keep classifier keyword list configurable.

Quantity parsing: CK may use words like “Out of stock” or “1 available” — ensure parser handles that.

Condition parsing: CK uses many abbreviations; ensure you normalize them.

Multiple workers/processes: in-memory caches don’t share state — use Redis for multi-instance deployments.

8) Prioritized todo checklist (short)

 Wrap container sell updates in DB transactions (done snippet above).

 Add fetch timeout/retry (use snippets above).

 Print/validate edition strings in logs for suspicious items (debug only).

 Add rate limiting and concurrency caps for scraping endpoints.

 Add input validation (Joi/Zod) for POST endpoints.

 Add health endpoint and graceful shutdown.

 Add tests (Jest + nock) for parsers and /api/prices.

 Add caching (Redis) and metrics (Prometheus) if traffic grows.