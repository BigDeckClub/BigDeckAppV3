// ========== STEP 1: FIX DATABASE SCHEMA ==========
// Run this SQL in your database first:

/*
-- Check current foreign key constraint
SELECT 
    tc.constraint_name, 
    tc.table_name, 
    kcu.column_name, 
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name,
    rc.delete_rule
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
  AND tc.table_schema = kcu.table_schema
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
  AND ccu.table_schema = tc.table_schema
JOIN information_schema.referential_constraints AS rc
  ON tc.constraint_name = rc.constraint_name
WHERE tc.table_name = 'sales' AND tc.constraint_type = 'FOREIGN KEY';

-- If constraint exists with CASCADE, drop it
ALTER TABLE sales DROP CONSTRAINT IF EXISTS sales_container_id_fkey;

-- Recreate without foreign key (sales are historical records, container may be deleted)
-- Or use SET NULL if you want to keep the reference when possible
ALTER TABLE sales 
  ADD CONSTRAINT sales_container_id_fkey 
  FOREIGN KEY (container_id) 
  REFERENCES containers(id) 
  ON DELETE SET NULL;  -- ← SET NULL instead of CASCADE

-- Better yet: Remove the foreign key entirely for sales (historical data)
ALTER TABLE sales DROP CONSTRAINT IF EXISTS sales_container_id_fkey;
*/

// ========== STEP 2: FIXED SELL CONTAINER ENDPOINT ==========
app.post('/api/containers/:id/sell', async (req, res) => {
  const client = await pool.connect();
  
  try {
    const { salePrice } = req.body;
    
    // Validate sale price
    const parsedPrice = parseFloat(salePrice);
    if (isNaN(parsedPrice) || parsedPrice < 0) {
      return res.status(400).json({ 
        error: 'Invalid sale price', 
        received: salePrice 
      });
    }

    await client.query('BEGIN');
    console.log(`[SELL] Transaction started`);

    // Get container details INCLUDING decklist_id for COGS calculation
    const containerResult = await client.query(
      'SELECT id, name, decklist_id, cards FROM containers WHERE id = $1',
      [req.params.id]
    );
    
    if (containerResult.rows.length === 0) {
      await client.query('ROLLBACK');
      console.log(`[SELL] ❌ Container not found: ${req.params.id}`);
      return res.status(404).json({ error: 'Container not found' });
    }

    const container = containerResult.rows[0];
    const cards = container.cards || [];

    console.log(`[SELL CONTAINER] ID: ${container.id}, Name: ${container.name}, Decklist: ${container.decklist_id}, Price: $${parsedPrice}`);

    // Decrement inventory (cards are sold and leave inventory)
    for (const card of cards) {
      if (card.inventoryId && card.quantity_used > 0) {
        const updateResult = await client.query(
          `UPDATE inventory 
           SET quantity = GREATEST(0, quantity - $1),
               quantity_in_containers = GREATEST(0, COALESCE(quantity_in_containers, 0) - $1)
           WHERE id = $2
           RETURNING id, quantity`,
          [card.quantity_used, card.inventoryId]
        );
        
        if (updateResult.rows.length > 0) {
          console.log(`[SELL] ✅ Inventory decremented: id=${updateResult.rows[0].id}, new_qty=${updateResult.rows[0].quantity}`);
        }
      }
    }

    // ✅ CRITICAL FIX: DELETE CONTAINER BEFORE INSERTING SALE
    // This prevents cascade delete if there's a FK constraint
    await client.query('DELETE FROM containers WHERE id = $1', [container.id]);
    console.log(`[SELL] ✅ Container deleted: id=${container.id}`);

    // Insert sale record AFTER deleting container (avoids FK cascade issues)
    const saleResult = await client.query(
      `INSERT INTO sales (
        container_id, 
        sale_price, 
        sold_date, 
        decklist_id,
        created_at
      ) VALUES ($1, $2, NOW(), $3, NOW()) 
      RETURNING *`,
      [container.id, parsedPrice, container.decklist_id]
    );

    if (!saleResult.rows[0]) {
      throw new Error('Sale insert returned no data');
    }

    const sale = saleResult.rows[0];
    console.log(`[SALE INSERTED] ID: ${sale.id}, Container: ${container.name}, Price: $${parsedPrice}`);

    // Verify sale exists before commit
    const verifyResult = await client.query(
      'SELECT id, container_id, sale_price FROM sales WHERE id = $1',
      [sale.id]
    );
    
    if (verifyResult.rows.length === 0) {
      throw new Error(`Sale ${sale.id} not found after insert - transaction issue`);
    }
    
    console.log(`[SALE VERIFIED] Sale ${sale.id} exists in transaction`);

    // Commit transaction
    await client.query('COMMIT');
    console.log(`[SELL] ✅ Transaction committed`);

    // CRITICAL: Verify sale persisted after commit
    const postCommitVerify = await pool.query(
      'SELECT id, container_id, sale_price, sold_date FROM sales WHERE id = $1',
      [sale.id]
    );
    
    if (postCommitVerify.rows.length === 0) {
      console.error(`[SELL] ❌ CRITICAL: Sale ${sale.id} NOT FOUND after commit!`);
      return res.status(500).json({ 
        error: 'Sale was not persisted', 
        saleId: sale.id 
      });
    }
    
    console.log(`[SALE RECORDED] Container: ${container.name}, Price: $${parsedPrice}, Sale ID: ${sale.id} ✅ PERSISTED`);
    
    // Return the sale data
    res.json({
      ...sale,
      container_name: container.name  // Add container name for display
    });

  } catch (err) {
    await client.query('ROLLBACK');
    console.error('[SELL] ❌ Transaction rolled back:', err);
    console.error('[SELL] Error stack:', err.stack);
    res.status(500).json({ 
      error: 'Failed to sell container', 
      details: err.message 
    });
  } finally {
    client.release();
  }
});

// ========== STEP 3: ENHANCED GET SALES ENDPOINT ==========
app.get('/api/sales', async (req, res) => {
  try {
    console.log('[GET SALES] Fetching sales records...');
    
    const result = await pool.query(`
      SELECT 
        s.id,
        s.container_id,
        s.sale_price,
        s.sold_date,
        s.created_at,
        s.decklist_id,
        d.name as decklist_name
      FROM sales s
      LEFT JOIN decklists d ON s.decklist_id = d.id
      ORDER BY COALESCE(s.sold_date, s.created_at) DESC
    `);
    
    console.log(`[GET SALES] ✅ Found ${result.rows.length} sales records`);
    
    if (result.rows.length > 0) {
      console.log(`[GET SALES] Sample record:`, JSON.stringify(result.rows[0], null, 2));
    }
    
    // Map to frontend-expected format
    const sales = result.rows.map(sale => ({
      id: sale.id,
      container_id: sale.container_id,
      sale_price: parseFloat(sale.sale_price),
      sold_date: sale.sold_date || sale.created_at,
      created_at: sale.created_at || sale.sold_date,
      decklist_id: sale.decklist_id,
      decklist_name: sale.decklist_name
    }));
    
    res.json(sales);
  } catch (err) {
    console.error('[GET SALES] ❌ Query error:', err);
    console.error('[GET SALES] Error stack:', err.stack);
    res.status(500).json({ 
      error: 'Failed to fetch sales',
      details: err.message 
    });
  }
});

// ========== STEP 4: DEBUG ENDPOINT (Temporary - Remove in production) ==========
app.get('/api/sales/debug', async (req, res) => {
  try {
    // Check table structure
    const tableInfo = await pool.query(`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns
      WHERE table_name = 'sales'
      ORDER BY ordinal_position
    `);
    
    // Check foreign key constraints
    const constraints = await pool.query(`
      SELECT 
        tc.constraint_name, 
        tc.constraint_type,
        kcu.column_name,
        rc.delete_rule
      FROM information_schema.table_constraints tc
      LEFT JOIN information_schema.key_column_usage kcu 
        ON tc.constraint_name = kcu.constraint_name
      LEFT JOIN information_schema.referential_constraints rc
        ON tc.constraint_name = rc.constraint_name
      WHERE tc.table_name = 'sales'
    `);
    
    // Check sales count
    const count = await pool.query('SELECT COUNT(*) as total FROM sales');
    
    // Get recent sales
    const recentSales = await pool.query(`
      SELECT * FROM sales 
      ORDER BY COALESCE(sold_date, created_at) DESC 
      LIMIT 5
    `);
    
    res.json({
      columns: tableInfo.rows,
      constraints: constraints.rows,
      total_sales: parseInt(count.rows[0].total),
      recent_sales: recentSales.rows
    });
  } catch (err) {
    res.status(500).json({ error: err.message, stack: err.stack });
  }
});