# Decks Tab Feature Implementation Instructions

## Overview

Implement a two-tier deck system:
1. **Decklists** (templates) - Live in Decks Tab, never interact with inventory
2. **Decks** (inventory instances) - Created by copying a decklist, live as special folders in Inventory Tab, pull actual cards from inventory

The key workflow: User creates a decklist ‚Üí User clicks "Copy to Deck" ‚Üí System finds cheapest available cards from inventory ‚Üí Creates a deck folder in Inventory with reserved cards. 

---

## Phase 1: Database Schema Changes

### 1. 1 Update the database initialization in `server. js`

Add these new tables after the existing table creation:

```sql
-- Deck reservations: tracks which inventory items are reserved for which deck
CREATE TABLE IF NOT EXISTS deck_reservations (
  id SERIAL PRIMARY KEY,
  deck_id INTEGER REFERENCES decks(id) ON DELETE CASCADE,
  inventory_item_id INTEGER REFERENCES inventory(id) ON DELETE CASCADE,
  quantity_reserved INTEGER NOT NULL,
  original_folder VARCHAR(255),
  reserved_at TIMESTAMP DEFAULT NOW()
);

-- Deck missing cards: tracks cards needed but not in inventory
CREATE TABLE IF NOT EXISTS deck_missing_cards (
  id SERIAL PRIMARY KEY,
  deck_id INTEGER REFERENCES decks(id) ON DELETE CASCADE,
  card_name VARCHAR(255) NOT NULL,
  set_code VARCHAR(20),
  quantity_needed INTEGER NOT NULL
);
```

### 1.2 Add `decklist_id` column to decks table

```sql
ALTER TABLE decks ADD COLUMN IF NOT EXISTS decklist_id INTEGER REFERENCES decklists(id) ON DELETE SET NULL;
```

### 1.3 Add `is_deck_instance` column to decks table

This distinguishes between decklists (templates) and deck instances (inventory folders):

```sql
ALTER TABLE decks ADD COLUMN IF NOT EXISTS is_deck_instance BOOLEAN DEFAULT FALSE;
```

---

## Phase 2: Backend API Endpoints

### 2.1 Create endpoint: POST `/api/decks/:id/copy-to-inventory`

This is the core endpoint that copies a decklist to an inventory deck.

**Location:** Add to `server.js` after existing deck endpoints

**Logic:**
```javascript
app.post('/api/decks/:id/copy-to-inventory', async (req, res) => {
  const { id } = req.params; // decklist ID
  const { name } = req.body; // optional custom name for the deck instance
  
  try {
    // 1. Get the source decklist
    const decklistResult = await pool.query('SELECT * FROM decks WHERE id = $1', [id]);
    if (decklistResult.rows. length === 0) {
      return res.status(404).json({ error: 'Decklist not found' });
    }
    const decklist = decklistResult.rows[0];
    const cards = decklist.cards || [];
    
    // 2. Create new deck instance
    const deckName = name || decklist.name;
    const newDeckResult = await pool.query(
      `INSERT INTO decks (name, format, description, cards, decklist_id, is_deck_instance, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, TRUE, NOW(), NOW())
       RETURNING *`,
      [deckName, decklist.format, decklist.description, JSON.stringify(cards), id]
    );
    const newDeck = newDeckResult.rows[0];
    
    // 3. For each card in decklist, find cheapest available inventory
    const reservations = [];
    const missingCards = [];
    
    for (const card of cards) {
      const cardName = card.name;
      const quantityNeeded = card.quantity || 1;
      
      // Find all inventory items matching this card name, sorted by purchase_price ASC
      // Exclude items already fully reserved for other decks
      const inventoryResult = await pool.query(`
        SELECT i.*, 
          COALESCE(i.quantity, 0) - COALESCE(
            (SELECT SUM(dr.quantity_reserved) FROM deck_reservations dr WHERE dr.inventory_item_id = i.id), 0
          ) as available_quantity
        FROM inventory i
        WHERE LOWER(TRIM(i.name)) = LOWER(TRIM($1))
        HAVING COALESCE(i.quantity, 0) - COALESCE(
          (SELECT SUM(dr.quantity_reserved) FROM deck_reservations dr WHERE dr.inventory_item_id = i.id), 0
        ) > 0
        ORDER BY COALESCE(i.purchase_price, 999999) ASC
      `, [cardName]);
      
      let remainingNeeded = quantityNeeded;
      
      for (const invItem of inventoryResult.rows) {
        if (remainingNeeded <= 0) break;
        
        const availableQty = invItem.available_quantity;
        const reserveQty = Math.min(remainingNeeded, availableQty);
        
        if (reserveQty > 0) {
          reservations.push({
            deck_id: newDeck.id,
            inventory_item_id: invItem. id,
            quantity_reserved: reserveQty,
            original_folder: invItem.folder || 'Uncategorized'
          });
          remainingNeeded -= reserveQty;
        }
      }
      
      // If still need more, add to missing cards
      if (remainingNeeded > 0) {
        missingCards.push({
          deck_id: newDeck.id,
          card_name: cardName,
          set_code: card.set || null,
          quantity_needed: remainingNeeded
        });
      }
    }
    
    // 4. Insert all reservations
    for (const res of reservations) {
      await pool.query(
        `INSERT INTO deck_reservations (deck_id, inventory_item_id, quantity_reserved, original_folder)
         VALUES ($1, $2, $3, $4)`,
        [res.deck_id, res.inventory_item_id, res.quantity_reserved, res.original_folder]
      );
    }
    
    // 5. Insert all missing cards
    for (const missing of missingCards) {
      await pool.query(
        `INSERT INTO deck_missing_cards (deck_id, card_name, set_code, quantity_needed)
         VALUES ($1, $2, $3, $4)`,
        [missing.deck_id, missing.card_name, missing.set_code, missing.quantity_needed]
      );
    }
    
    // 6. Return the new deck with reservation and missing info
    res.status(201).json({
      deck: newDeck,
      reservations: reservations,
      missingCards: missingCards,
      totalCards: cards.reduce((sum, c) => sum + (c.quantity || 1), 0),
      reservedCount: reservations.reduce((sum, r) => sum + r.quantity_reserved, 0),
      missingCount: missingCards.reduce((sum, m) => sum + m.quantity_needed, 0)
    });
    
  } catch (error) {
    console.error('[DECKS] Error copying to inventory:', error. message);
    res.status(500).json({ error: 'Failed to copy deck to inventory' });
  }
});
```

### 2. 2 Create endpoint: GET `/api/deck-instances`

Get all deck instances (for Inventory Tab sidebar).

```javascript
app.get('/api/deck-instances', async (req, res) => {
  try {
    const result = await pool. query(`
      SELECT d.*,
        (SELECT COALESCE(SUM(dr.quantity_reserved), 0) FROM deck_reservations dr WHERE dr.deck_id = d.id) as reserved_count,
        (SELECT COALESCE(SUM(dm.quantity_needed), 0) FROM deck_missing_cards dm WHERE dm.deck_id = d. id) as missing_count
      FROM decks d
      WHERE d.is_deck_instance = TRUE
      ORDER BY d.created_at DESC
    `);
    res.json(result.rows);
  } catch (error) {
    console.error('[DECKS] Error fetching deck instances:', error.message);
    res.status(500).json({ error: 'Failed to fetch deck instances' });
  }
});
```

### 2.3 Create endpoint: GET `/api/deck-instances/:id/details`

Get full details of a deck instance including reservations and missing cards.

```javascript
app.get('/api/deck-instances/:id/details', async (req, res) => {
  const { id } = req.params;
  
  try {
    // Get deck
    const deckResult = await pool.query('SELECT * FROM decks WHERE id = $1 AND is_deck_instance = TRUE', [id]);
    if (deckResult.rows.length === 0) {
      return res.status(404).json({ error: 'Deck instance not found' });
    }
    const deck = deckResult.rows[0];
    
    // Get reservations with inventory details
    const reservationsResult = await pool.query(`
      SELECT dr.*, i.name, i.set, i.purchase_price, i.folder, i.quantity as inventory_quantity
      FROM deck_reservations dr
      JOIN inventory i ON dr.inventory_item_id = i.id
      WHERE dr. deck_id = $1
      ORDER BY i.name, i.purchase_price ASC
    `, [id]);
    
    // Get missing cards
    const missingResult = await pool.query(`
      SELECT * FROM deck_missing_cards WHERE deck_id = $1 ORDER BY card_name
    `, [id]);
    
    // Calculate total cost
    const totalCost = reservationsResult.rows.reduce((sum, r) => {
      return sum + (parseFloat(r.purchase_price) || 0) * r.quantity_reserved;
    }, 0);
    
    res.json({
      deck: deck,
      reservations: reservationsResult.rows,
      missingCards: missingResult.rows,
      totalCost: totalCost,
      reservedCount: reservationsResult.rows.reduce((sum, r) => sum + r.quantity_reserved, 0),
      missingCount: missingResult.rows.reduce((sum, m) => sum + m.quantity_needed, 0)
    });
    
  } catch (error) {
    console.error('[DECKS] Error fetching deck details:', error.message);
    res. status(500).json({ error: 'Failed to fetch deck details' });
  }
});
```

### 2.4 Create endpoint: POST `/api/deck-instances/:id/add-card`

Add a card from inventory to an existing deck. 

```javascript
app.post('/api/deck-instances/:id/add-card', async (req, res) => {
  const { id } = req.params;
  const { inventory_item_id, quantity } = req.body;
  
  try {
    // Check available quantity
    const invResult = await pool.query(`
      SELECT i.*, 
        COALESCE(i.quantity, 0) - COALESCE(
          (SELECT SUM(dr.quantity_reserved) FROM deck_reservations dr WHERE dr.inventory_item_id = i.id), 0
        ) as available_quantity
      FROM inventory i WHERE i.id = $1
    `, [inventory_item_id]);
    
    if (invResult.rows.length === 0) {
      return res.status(404).json({ error: 'Inventory item not found' });
    }
    
    const invItem = invResult.rows[0];
    if (invItem.available_quantity < quantity) {
      return res. status(400).json({ error: 'Not enough available quantity' });
    }
    
    // Check if reservation already exists for this item in this deck
    const existingRes = await pool.query(
      'SELECT * FROM deck_reservations WHERE deck_id = $1 AND inventory_item_id = $2',
      [id, inventory_item_id]
    );
    
    if (existingRes. rows.length > 0) {
      // Update existing reservation
      await pool. query(
        'UPDATE deck_reservations SET quantity_reserved = quantity_reserved + $1 WHERE deck_id = $2 AND inventory_item_id = $3',
        [quantity, id, inventory_item_id]
      );
    } else {
      // Create new reservation
      await pool. query(
        `INSERT INTO deck_reservations (deck_id, inventory_item_id, quantity_reserved, original_folder)
         VALUES ($1, $2, $3, $4)`,
        [id, inventory_item_id, quantity, invItem.folder || 'Uncategorized']
      );
    }
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('[DECKS] Error adding card:', error.message);
    res.status(500).json({ error: 'Failed to add card' });
  }
});
```

### 2.5 Create endpoint: DELETE `/api/deck-instances/:id/remove-card`

Remove a card from a deck (release back to inventory).

```javascript
app.delete('/api/deck-instances/:id/remove-card', async (req, res) => {
  const { id } = req. params;
  const { reservation_id, quantity } = req.body;
  
  try {
    const resResult = await pool.query('SELECT * FROM deck_reservations WHERE id = $1 AND deck_id = $2', [reservation_id, id]);
    
    if (resResult.rows. length === 0) {
      return res.status(404).json({ error: 'Reservation not found' });
    }
    
    const reservation = resResult.rows[0];
    
    if (quantity >= reservation.quantity_reserved) {
      // Remove entire reservation
      await pool.query('DELETE FROM deck_reservations WHERE id = $1', [reservation_id]);
    } else {
      // Reduce quantity
      await pool.query(
        'UPDATE deck_reservations SET quantity_reserved = quantity_reserved - $1 WHERE id = $2',
        [quantity, reservation_id]
      );
    }
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('[DECKS] Error removing card:', error.message);
    res.status(500).json({ error: 'Failed to remove card' });
  }
});
```

### 2.6 Create endpoint: POST `/api/deck-instances/:id/release`

Release entire deck - return all cards to inventory and delete deck instance.

```javascript
app.post('/api/deck-instances/:id/release', async (req, res) => {
  const { id } = req.params;
  
  try {
    // Delete all reservations (cards automatically become available again)
    await pool.query('DELETE FROM deck_reservations WHERE deck_id = $1', [id]);
    
    // Delete missing cards
    await pool.query('DELETE FROM deck_missing_cards WHERE deck_id = $1', [id]);
    
    // Delete the deck instance
    await pool.query('DELETE FROM decks WHERE id = $1 AND is_deck_instance = TRUE', [id]);
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('[DECKS] Error releasing deck:', error.message);
    res. status(500).json({ error: 'Failed to release deck' });
  }
});
```

### 2.7 Create endpoint: POST `/api/deck-instances/:id/reoptimize`

Re-run the cheapest card selection for all cards in the deck.

```javascript
app.post('/api/deck-instances/:id/reoptimize', async (req, res) => {
  const { id } = req.params;
  
  try {
    // Get deck with its card list
    const deckResult = await pool.query('SELECT * FROM decks WHERE id = $1 AND is_deck_instance = TRUE', [id]);
    if (deckResult.rows.length === 0) {
      return res.status(404).json({ error: 'Deck not found' });
    }
    const deck = deckResult.rows[0];
    const cards = deck.cards || [];
    
    // Clear existing reservations
    await pool. query('DELETE FROM deck_reservations WHERE deck_id = $1', [id]);
    await pool.query('DELETE FROM deck_missing_cards WHERE deck_id = $1', [id]);
    
    // Re-run the same logic as copy-to-inventory
    const reservations = [];
    const missingCards = [];
    
    for (const card of cards) {
      const cardName = card. name;
      const quantityNeeded = card.quantity || 1;
      
      const inventoryResult = await pool.query(`
        SELECT i.*, 
          COALESCE(i.quantity, 0) - COALESCE(
            (SELECT SUM(dr.quantity_reserved) FROM deck_reservations dr WHERE dr.inventory_item_id = i.id), 0
          ) as available_quantity
        FROM inventory i
        WHERE LOWER(TRIM(i.name)) = LOWER(TRIM($1))
        HAVING COALESCE(i.quantity, 0) - COALESCE(
          (SELECT SUM(dr.quantity_reserved) FROM deck_reservations dr WHERE dr.inventory_item_id = i.id), 0
        ) > 0
        ORDER BY COALESCE(i.purchase_price, 999999) ASC
      `, [cardName]);
      
      let remainingNeeded = quantityNeeded;
      
      for (const invItem of inventoryResult. rows) {
        if (remainingNeeded <= 0) break;
        
        const availableQty = invItem.available_quantity;
        const reserveQty = Math.min(remainingNeeded, availableQty);
        
        if (reserveQty > 0) {
          reservations.push({
            deck_id: id,
            inventory_item_id: invItem.id,
            quantity_reserved: reserveQty,
            original_folder: invItem.folder || 'Uncategorized'
          });
          remainingNeeded -= reserveQty;
        }
      }
      
      if (remainingNeeded > 0) {
        missingCards.push({
          deck_id: id,
          card_name: cardName,
          set_code: card.set || null,
          quantity_needed: remainingNeeded
        });
      }
    }
    
    // Insert all reservations
    for (const res of reservations) {
      await pool.query(
        `INSERT INTO deck_reservations (deck_id, inventory_item_id, quantity_reserved, original_folder)
         VALUES ($1, $2, $3, $4)`,
        [res. deck_id, res.inventory_item_id, res.quantity_reserved, res.original_folder]
      );
    }
    
    // Insert all missing cards
    for (const missing of missingCards) {
      await pool. query(
        `INSERT INTO deck_missing_cards (deck_id, card_name, set_code, quantity_needed)
         VALUES ($1, $2, $3, $4)`,
        [missing.deck_id, missing. card_name, missing.set_code, missing.quantity_needed]
      );
    }
    
    res.json({
      success: true,
      reservedCount: reservations.reduce((sum, r) => sum + r. quantity_reserved, 0),
      missingCount: missingCards.reduce((sum, m) => sum + m.quantity_needed, 0)
    });
    
  } catch (error) {
    console.error('[DECKS] Error reoptimizing:', error.message);
    res. status(500).json({ error: 'Failed to reoptimize deck' });
  }
});
```

### 2.8 Create endpoint: PUT `/api/deck-instances/:id`

Update deck instance metadata (name, format, description).

```javascript
app.put('/api/deck-instances/:id', async (req, res) => {
  const { id } = req.params;
  const { name, format, description } = req.body;
  
  try {
    const updates = [];
    const values = [];
    let paramCount = 1;
    
    if (name !== undefined) {
      updates.push(`name = $${paramCount++}`);
      values.push(name);
    }
    if (format !== undefined) {
      updates.push(`format = $${paramCount++}`);
      values.push(format);
    }
    if (description !== undefined) {
      updates.push(`description = $${paramCount++}`);
      values.push(description);
    }
    
    if (updates.length === 0) {
      return res.status(400).json({ error: 'No updates provided' });
    }
    
    updates.push(`updated_at = NOW()`);
    values.push(id);
    
    const result = await pool.query(
      `UPDATE decks SET ${updates.join(', ')} WHERE id = $${paramCount} AND is_deck_instance = TRUE RETURNING *`,
      values
    );
    
    if (result.rows.length === 0) {
      return res. status(404).json({ error: 'Deck not found' });
    }
    
    res.json(result. rows[0]);
    
  } catch (error) {
    console.error('[DECKS] Error updating deck:', error.message);
    res.status(500). json({ error: 'Failed to update deck' });
  }
});
```

### 2. 9 Update GET `/api/decks` endpoint

Modify to only return decklists (templates), not deck instances:

```javascript
// Find the existing GET /api/decks endpoint and update it:
app.get('/api/decks', async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT * FROM decks 
      WHERE is_deck_instance = FALSE OR is_deck_instance IS NULL
      ORDER BY created_at DESC
    `);
    res.json(result.rows);
  } catch (error) {
    console.error('[DECKS] Error fetching decks:', error.message);
    res.status(500).json({ error: 'Failed to fetch decks' });
  }
});
```

---

## Phase 3: Frontend - Decks Tab Updates

### 3.1 Update `src/components/DeckTab. jsx`

Add "Copy to Deck" button to each decklist card.

**Add new state variables at the top of the component:**
```javascript
const [showCopyModal, setShowCopyModal] = useState(false);
const [copyingDeck, setCopyingDeck] = useState(null);
const [copyDeckName, setCopyDeckName] = useState('');
const [copyPreview, setCopyPreview] = useState(null);
const [isCopying, setIsCopying] = useState(false);
```

**Add function to preview inventory availability:**
```javascript
const previewCopyToDeck = async (deck) => {
  setCopyingDeck(deck);
  setCopyDeckName(deck.name);
  setShowCopyModal(true);
  
  // Optional: fetch preview of what will be reserved
  // This could be a lightweight endpoint that shows availability without creating anything
};
```

**Add function to execute the copy:**
```javascript
const executeCopyToDeck = async () => {
  if (!copyingDeck || !copyDeckName. trim()) return;
  
  setIsCopying(true);
  try {
    const response = await fetch(`${API_BASE}/decks/${copyingDeck.id}/copy-to-inventory`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: copyDeckName })
    });
    
    if (!response.ok) throw new Error('Failed to copy deck');
    
    const result = await response.json();
    
    setShowCopyModal(false);
    setCopyingDeck(null);
    setCopyDeckName('');
    setSuccessMessage(`Deck created!  ${result.reservedCount} cards reserved, ${result.missingCount} cards missing. `);
    setTimeout(() => setSuccessMessage(''), 5000);
    
  } catch (error) {
    console.error('Failed to copy deck:', error);
    alert('Error copying deck to inventory');
  } finally {
    setIsCopying(false);
  }
};
```

**Add "Copy to Deck" button in the deck card grid (around line 570-600):**

Find the deck card rendering and add a new button:
```jsx
<button
  onClick={(e) => {
    e. stopPropagation();
    previewCopyToDeck(deck);
  }}
  className="text-slate-400 hover:text-green-400 transition-colors"
  title="Copy to Inventory Deck"
>
  <Download className="w-4 h-4" />
</button>
```

**Add the Copy Modal at the bottom of the component (before the closing `</div>`):**
```jsx
{/* Copy to Deck Modal */}
{showCopyModal && copyingDeck && (
  <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
    <div className="bg-slate-800 rounded-lg border border-teal-500 p-6 max-w-md w-full">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold text-teal-300">Copy to Inventory Deck</h2>
        <button
          onClick={() => {
            setShowCopyModal(false);
            setCopyingDeck(null);
            setCopyDeckName('');
          }}
          className="text-slate-400 hover:text-white"
        >
          <X className="w-5 h-5" />
        </button>
      </div>
      
      <p className="text-slate-300 mb-4">
        This will create a deck in your Inventory tab and reserve the cheapest available copies of each card.
      </p>
      
      <div className="mb-4">
        <label className="block text-sm text-slate-400 mb-1">Deck Name</label>
        <input
          type="text"
          value={copyDeckName}
          onChange={(e) => setCopyDeckName(e.target.value)}
          placeholder="Enter deck name"
          className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white"
        />
      </div>
      
      <div className="bg-slate-900 rounded p-3 mb-4">
        <p className="text-sm text-slate-400">
          Source: <span className="text-teal-300">{copyingDeck.name}</span>
        </p>
        <p className="text-sm text-slate-400">
          Cards: <span className="text-teal-300">{(copyingDeck.cards || []).reduce((sum, c) => sum + (c.quantity || 1), 0)}</span>
        </p>
      </div>
      
      <div className="flex gap-2">
        <button
          onClick={() => {
            setShowCopyModal(false);
            setCopyingDeck(null);
            setCopyDeckName('');
          }}
          className="flex-1 bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded"
          disabled={isCopying}
        >
          Cancel
        </button>
        <button
          onClick={executeCopyToDeck}
          disabled={isCopying || !copyDeckName.trim()}
          className="flex-1 bg-teal-600 hover:bg-teal-700 text-white px-4 py-2 rounded font-semibold disabled:opacity-50"
        >
          {isCopying ?  'Creating...' : 'Create Deck'}
        </button>
      </div>
    </div>
  </div>
)}
```

---

## Phase 4: Frontend - Inventory Tab Updates

### 4.1 Update `src/components/InventoryTab.jsx`

**Add new state variables:**
```javascript
const [deckInstances, setDeckInstances] = useState([]);
const [selectedDeckInstance, setSelectedDeckInstance] = useState(null);
const [deckDetails, setDeckDetails] = useState(null);
const [loadingDeckDetails, setLoadingDeckDetails] = useState(false);
```

**Add useEffect to load deck instances:**
```javascript
useEffect(() => {
  loadDeckInstances();
}, []);

const loadDeckInstances = async () => {
  try {
    const response = await fetch('/api/deck-instances');
    if (response.ok) {
      const data = await response.json();
      setDeckInstances(data);
    }
  } catch (error) {
    console. error('Failed to load deck instances:', error);
  }
};
```

**Add function to load deck details:**
```javascript
const loadDeckDetails = async (deckId) => {
  setLoadingDeckDetails(true);
  try {
    const response = await fetch(`/api/deck-instances/${deckId}/details`);
    if (response.ok) {
      const data = await response.json();
      setDeckDetails(data);
    }
  } catch (error) {
    console.error('Failed to load deck details:', error);
  } finally {
    setLoadingDeckDetails(false);
  }
};
```

**Add function to release a deck:**
```javascript
const releaseDeck = async (deckId) => {
  if (!window.confirm('Are you sure you want to release this deck? All cards will be returned to inventory.')) {
    return;
  }
  
  try {
    const response = await fetch(`/api/deck-instances/${deckId}/release`, {
      method: 'POST'
    });
    
    if (response.ok) {
      setSelectedDeckInstance(null);
      setDeckDetails(null);
      loadDeckInstances();
      setSuccessMessage('Deck released!  Cards returned to inventory.');
      setTimeout(() => setSuccessMessage(''), 3000);
    }
  } catch (error) {
    console.error('Failed to release deck:', error);
  }
};
```

**Add function to reoptimize a deck:**
```javascript
const reoptimizeDeck = async (deckId) => {
  try {
    const response = await fetch(`/api/deck-instances/${deckId}/reoptimize`, {
      method: 'POST'
    });
    
    if (response.ok) {
      const result = await response.json();
      loadDeckDetails(deckId);
      setSuccessMessage(`Deck reoptimized! ${result.reservedCount} cards reserved. `);
      setTimeout(() => setSuccessMessage(''), 3000);
    }
  } catch (error) {
    console. error('Failed to reoptimize deck:', error);
  }
};
```

**Add Decks section to the sidebar (after the Folders section, around line 470):**
```jsx
{/* Deck Instances Section */}
<div className="rounded-lg p-4 border-2 border-purple-500/50 bg-gradient-to-br from-slate-900/50 to-slate-800/50 space-y-3 max-h-64 overflow-y-auto mt-4">
  <div className="flex items-center justify-between mb-3">
    <h3 className="text-sm font-semibold text-purple-300">üé¥ Decks</h3>
  </div>
  
  {deckInstances.length === 0 ? (
    <p className="text-xs text-slate-500">No decks yet. Create one from the Decks tab!</p>
  ) : (
    deckInstances.map((deck) => {
      const totalCards = (deck.cards || []).reduce((sum, c) => sum + (c.quantity || 1), 0);
      const reservedCount = deck.reserved_count || 0;
      const missingCount = deck.missing_count || 0;
      const completionPercent = totalCards > 0 ? Math.round((reservedCount / totalCards) * 100) : 0;
      const isSelected = selectedDeckInstance?.id === deck.id;
      
      return (
        <button
          key={deck.id}
          onClick={() => {
            setSelectedDeckInstance(isSelected ? null : deck);
            setSelectedFolder(null);
            setActiveTab('deck');
            if (! isSelected) {
              loadDeckDetails(deck.id);
            } else {
              setDeckDetails(null);
            }
          }}
          className={`w-full text-left p-3 rounded-lg transition-colors ${
            isSelected
              ?  'bg-purple-600/40 border-l-4 border-purple-400'
              : 'bg-slate-800 border-l-4 border-transparent hover:bg-slate-700'
          }`}
        >
          <div className="font-medium text-sm text-slate-100">{deck.name}</div>
          <div className="flex justify-between items-center">
            <span className="text-xs text-purple-300">{reservedCount}/{totalCards} cards</span>
            <span className={`text-xs ${completionPercent === 100 ? 'text-green-400' : 'text-yellow-400'}`}>
              {completionPercent}%
            </span>
          </div>
        </button>
      );
    })
  )}
</div>
```

**Add deck detail view in the main content area (add a new condition around line 585):**
```jsx
{/* Deck Instance Detail View */}
{activeTab === 'deck' && selectedDeckInstance && (
  <div className="space-y-4">
    <div className="flex justify-between items-center">
      <div>
        <h2 className="text-xl font-bold text-purple-300">{selectedDeckInstance.name}</h2>
        <p className="text-sm text-slate-400">
          {selectedDeckInstance.format} ‚Ä¢ {deckDetails?.reservedCount || 0}/{(selectedDeckInstance.cards || []). reduce((sum, c) => sum + (c.quantity || 1), 0)} cards
        </p>
        {deckDetails && (
          <p className="text-sm text-green-400">
            Total Cost: ${deckDetails.totalCost?. toFixed(2) || '0.00'}
          </p>
        )}
      </div>
      <div className="flex gap-2">
        <button
          onClick={() => reoptimizeDeck(selectedDeckInstance.id)}
          className="bg-teal-600 hover:bg-teal-700 text-white px-3 py-1 rounded text-sm"
          title="Re-optimize for cheapest cards"
        >
          üîÑ Re-optimize
        </button>
        <button
          onClick={() => releaseDeck(selectedDeckInstance.id)}
          className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm"
          title="Release deck and return cards"
        >
          Release
        </button>
      </div>
    </div>
    
    {loadingDeckDetails ?  (
      <div className="text-center py-8">
        <div className="w-8 h-8 animate-spin mx-auto text-purple-400 border-2 border-purple-400 border-t-transparent rounded-full"></div>
      </div>
    ) : deckDetails ? (
      <>
        {/* Reserved Cards */}
        <div className="bg-slate-800 rounded-lg p-4 border border-slate-600">
          <h3 className="text-lg font-semibold text-green-400 mb-3">‚úÖ Reserved Cards ({deckDetails.reservedCount})</h3>
          <div className="space-y-2 max-h-64 overflow-y-auto">
            {deckDetails.reservations.map((res, idx) => (
              <div key={idx} className="flex justify-between items-center bg-slate-700 p-2 rounded text-sm">
                <div>
                  <span className="text-white">{res.quantity_reserved}x {res.name}</span>
                  <span className="text-slate-400 ml-2">({res.set})</span>
                </div>
                <div className="flex items-center gap-3">
                  <span className="text-green-400">${(parseFloat(res.purchase_price) * res.quantity_reserved).toFixed(2)}</span>
                  <span className="text-xs text-slate-500">from {res.original_folder}</span>
                </div>
              </div>
            ))}
          </div>
        </div>
        
        {/* Missing Cards */}
        {deckDetails.missingCards.length > 0 && (
          <div className="bg-slate-800 rounded-lg p-4 border border-red-500/50">
            <h3 className="text-lg font-semibold text-red-400 mb-3">‚ùå Missing Cards ({deckDetails.missingCount})</h3>
            <div className="space-y-2 max-h-40 overflow-y-auto">
              {deckDetails.missingCards.map((missing, idx) => (
                <div key={idx} className="flex justify-between items-center bg-slate-700 p-2 rounded text-sm">
                  <span className="text-white">{missing.quantity_needed}x {missing.card_name}</span>
                  <button
                    className="text-xs bg-purple-600 hover:bg-purple-700 px-2 py-1 rounded"
                    onClick={() => {
                      // TODO: Integrate with Imports tab
                      alert('Add to Imports feature coming soon!');
                    }}
                  >
                    Add to Import
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
      </>
    ) : (
      <p className="text-slate-400">Select a deck to view details</p>
    )}
  </div>
)}
```

---

## Phase 5: Testing Checklist

After implementation, verify these workflows:

1. **Create a decklist** in Decks Tab (text import or build)
2. **Verify decklist persists** after creation
3. **Click "Copy to Deck"** on a decklist
4. **Verify deck instance appears** in Inventory Tab sidebar under "Decks"
5. **Click on deck instance** and verify:
   - Reserved cards show with prices and source folders
   - Missing cards show if any cards weren't in inventory
   - Total cost is calculated correctly
6. **Test "Re-optimize"** - should re-select cheapest available cards
7. **Test "Release"** - should delete deck instance and free up cards
8. **Copy same decklist again** - should create a second deck instance
9. **Verify original decklist still exists** in Decks Tab

---

## Summary of Files to Modify

| File | Changes |
|------|---------|
| `server.js` | Add new tables, add 8 new API endpoints, modify GET /api/decks |
| `src/components/DeckTab.jsx` | Add "Copy to Deck" button, add copy modal, add state/functions |
| `src/components/InventoryTab.jsx` | Add Decks section to sidebar, add deck detail view, add state/functions |

---

## Notes

- The cheapest-first algorithm sorts by `purchase_price` ascending, with NULL prices treated as very expensive (999999)
- Cards are matched by name (case-insensitive, trimmed)
- Reservations don't physically move cards - they just track allocation
- A card can be partially reserved (e.g., 2 of 4 copies reserved for a deck)
- Multiple decks can be created from the same decklist
- Releasing a deck frees up the reserved cards immediately