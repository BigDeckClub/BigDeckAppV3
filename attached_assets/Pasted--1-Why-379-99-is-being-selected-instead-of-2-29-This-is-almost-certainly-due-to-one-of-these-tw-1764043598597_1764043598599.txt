âœ… 1. Why $379.99 is being selected instead of $2.29

This is almost certainly due to one of these two Card Kingdom behaviors, both of which are confirmed by CK HTML structure:

Cause A â€” You're scraping a â€œPremium / Masterpiece / Foil Retroâ€ variant FIRST

Card Kingdom search results commonly show:

High-priced premium variants (e.g., Judge Promo, Special Edition)

Then the normal cheap one

Example ordering CK often uses for â€œLightning Boltâ€:

Product Variant	Price
Judge Promo	$379.99
Secret Lair Foil	$49.99
FNM Promo	$14.99
Regular Edition	$2.29

If your code:

Scrapes only the first div.productCard,

Or uses a selector that hits a promo listing first,
you will naturally get $379.99.

This is the most common cause.

Cause B â€” Your regex fallback returns the FIRST price inside the FIRST productCard

If div.productCard is scoped incorrectly:

Example product HTML:

<div class="productCard">
    <a>Lightning Bolt (Judge Promo)</a>
    <span class="stylePrice">$379.99</span>
</div>

<div class="productCard">
    <a>Lightning Bolt (Revised)</a>
    <span class="stylePrice">$2.29</span>
</div>


If you do:

const productHtml = $('div.productCard').first().html();
const prices = productHtml.match(/\$([0-9]+\.[0-9]{2})/g);


you only look inside the first card, not all cards.

So your fallback returns:

Correctly filtered

Correctly extracted

But WRONG PRODUCT

ğŸš¨ Root cause: Your selector + scoping assume the FIRST productCard is the correct product, but CK often sorts most expensive first.

This is the whole bug.

âœ… 2. Better selector: get ALL productCards, then find price inside each

Instead of:

$('div.productCard').first()


Use:

const products = $('div.productCard');


Then extract name + price from each, e.g.:

products.each((i, el) => {
  const name = $(el).find('.productCard-name-selector').text();
  const price = $(el).find('span.stylePrice').first().text();
});


The exact name selector varies, so use a flexible version:

$(el).find('a').first().text()

ğŸ† Correct algorithm for consistent lowest-price extraction

You want:

Only listings where the name contains exactly â€œLightning Boltâ€

Extract all corresponding prices

Return the minimum

This solves all search order issues.

ğŸ§  3. Improved logic to make sure you're scraping the RIGHT product

Add a product verification step:

const target = "lightning bolt";

const products = $('div.productCard').map((i, el) => {
    const name = $(el).find('a').first().text().trim().toLowerCase();

    if (!name.includes(target)) return null;  // skip wrong cards, promos, tokens

    const rawPrice = $(el).find('span.stylePrice').first().text().trim();
    const numeric = parseFloat(rawPrice.replace(/[^0-9.]/g, ''));

    return isNaN(numeric) ? null : numeric;
}).get();


Then:

const ckPrice = products.length ? Math.min(...products) : 'N/A';


This guarantees:

Wrong cards are ignored

Premium-only variants don't override regular copies

Regex fallback becomes unnecessary except for "sold out" states

ğŸ” 4. Add debugging logs so you can see EXACTLY what's happening

Add this inside your scraping function:

console.log("=== DEBUG: Card Kingdom Price Extraction ===");

$('div.productCard').each((i, el) => {
    const name = $(el).find('a').first().text().trim();
    const prices = $(el).find('span.stylePrice').map((j, p) =>
        $(p).text().trim()
    ).get();

    console.log(`Product #${i + 1}:`);
    console.log("  Name:", name);
    console.log("  Prices:", prices);
});


This will print something like:

Product #1:
  Name: Lightning Bolt (Judge Promo)
  Prices: ["$379.99"]

Product #2:
  Name: Lightning Bolt
  Prices: ["$2.29"]


Immediately showing you:

Why your scraper picked the wrong one

What the actual order of products is

Whether selectors are functioning correctly

ğŸ§± 5. If Cheerio still fails occasionally, use regex on each productCardâ€”not the whole page

Replace:

productHtml.match(...)


with:

$(el).html().match(...)


This keeps each price scoped to the correct card.

ğŸ Final Recommended Pipeline (Best Practice)
âœ” Step 1 â€” Get ALL product cards
âœ” Step 2 â€” Extract each cardâ€™s:

name

price(s)

âœ” Step 3 â€” Filter only cards where name matches target
âœ” Step 4 â€” Get all prices across all matching products
âœ” Step 5 â€” Return Math.min(...)

This handles:

Premium variants

Search result ordering

Duplicates

Bad selectors

Regex edge cases

Cards with multiple versions