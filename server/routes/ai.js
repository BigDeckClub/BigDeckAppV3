import express from 'express';
import { z } from 'zod';
import { pool } from '../db/pool.js';
import { authenticateApiKey, aiApiLimiter } from '../middleware/index.js';
import { mtgjsonService } from '../mtgjsonPriceService.js';
import { validateBody } from '../utils/validation.js';

const router = express.Router();

// ========== VALIDATION SCHEMAS ==========

/**
 * Schema for creating a deck via AI agent
 */
const createAIDeckSchema = z.object({
  userId: z.string().uuid('Invalid user ID format'),
  name: z.string().min(1, 'Deck name is required').max(255),
  format: z.string().max(50).optional().default('Commander'),
  description: z.string().max(2000).optional().default(''),
  cards: z.array(z.object({
    name: z.string().min(1, 'Card name is required'),
    quantity: z.number().int().positive().optional().default(1),
    set: z.string().max(10).optional().nullable(),
    collector_number: z.string().max(20).optional().nullable(),
    scryfall_id: z.string().uuid().optional().nullable(),
  })).min(1, 'At least one card is required'),
});

/**
 * Schema for batch price lookup
 */
const batchPricesSchema = z.object({
  scryfallIds: z.array(z.string().uuid()).min(1, 'At least one Scryfall ID is required').max(500, 'Maximum 500 cards per request'),
});

// ========== AI INTEGRATION ENDPOINTS ==========
// All endpoints require API key authentication via X-API-Key header

/**
 * GET /api/ai/inventory/:userId
 * Fetch a user's complete card inventory for AI deck building
 * Returns inventory items with available quantities (accounting for deck reservations)
 */
router.get('/ai/inventory/:userId', aiApiLimiter, authenticateApiKey, async (req, res) => {
  const { userId } = req.params;
  
  // Validate userId is a valid UUID
  const uuidResult = z.string().uuid().safeParse(userId);
  if (!uuidResult.success) {
    return res.status(400).json({ error: 'Invalid user ID format' });
  }
  
  try {
    // Check if user exists
    const userCheck = await pool.query('SELECT id FROM users WHERE id = $1', [userId]);
    if (userCheck.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Fetch complete inventory with available quantities
    const result = await pool.query(
      `SELECT 
        i.id,
        i.name,
        i.set,
        i.set_name,
        i.quantity,
        i.scryfall_id,
        i.foil,
        i.quality,
        i.folder,
        COALESCE(i.quantity, 0) - COALESCE(
          (SELECT SUM(dr.quantity_reserved) FROM deck_reservations dr WHERE dr.inventory_item_id = i.id), 0
        ) as available_quantity
       FROM inventory i 
       WHERE i.user_id = $1
       ORDER BY i.name ASC`,
      [userId]
    );
    
    res.json({
      userId,
      totalItems: result.rows.length,
      inventory: result.rows
    });
  } catch (error) {
    console.error('[AI-API] Error fetching inventory:', error.message);
    res.status(500).json({ error: 'Failed to fetch inventory' });
  }
});

/**
 * POST /api/ai/deck
 * Save a new deck generated by the AI agent
 * Creates a deck template (not a deck instance)
 */
router.post('/ai/deck', aiApiLimiter, authenticateApiKey, validateBody(createAIDeckSchema), async (req, res) => {
  const { userId, name, format, description, cards } = req.body;
  
  try {
    // Verify user exists
    const userCheck = await pool.query('SELECT id FROM users WHERE id = $1', [userId]);
    if (userCheck.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Create the deck
    const result = await pool.query(
      `INSERT INTO decks (user_id, name, format, description, cards, is_deck_instance, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, FALSE, NOW(), NOW())
       RETURNING *`,
      [userId, name, format, description, JSON.stringify(cards)]
    );
    
    const deck = result.rows[0];
    
    console.log(`[AI-API] Created deck "${name}" for user ${userId} with ${cards.length} unique cards`);
    
    res.status(201).json({
      message: 'Deck created successfully',
      deck: {
        id: deck.id,
        name: deck.name,
        format: deck.format,
        description: deck.description,
        cardCount: cards.reduce((sum, c) => sum + (c.quantity || 1), 0),
        uniqueCards: cards.length,
        createdAt: deck.created_at
      }
    });
  } catch (error) {
    console.error('[AI-API] Error creating deck:', error.message);
    res.status(500).json({ error: 'Failed to create deck' });
  }
});

/**
 * POST /api/ai/prices
 * Batch card price lookup by Scryfall IDs
 * Returns Card Kingdom prices from MTGJSON data
 */
router.post('/ai/prices', aiApiLimiter, authenticateApiKey, validateBody(batchPricesSchema), async (req, res) => {
  const { scryfallIds } = req.body;
  
  try {
    const prices = {};
    
    for (const scryfallId of scryfallIds) {
      try {
        const ckPrice = mtgjsonService.getCardKingdomPriceByScryfallId(scryfallId);
        prices[scryfallId] = {
          cardKingdom: ckPrice || null,
        };
      } catch (_err) {
        prices[scryfallId] = { cardKingdom: null };
      }
    }
    
    res.json({
      requestedCount: scryfallIds.length,
      prices
    });
  } catch (error) {
    console.error('[AI-API] Error fetching prices:', error.message);
    res.status(500).json({ error: 'Failed to fetch prices' });
  }
});

/**
 * GET /api/ai/user/:userId
 * Convenience endpoint for fetching user data
 * Returns basic user info and summary statistics
 */
router.get('/ai/user/:userId', aiApiLimiter, authenticateApiKey, async (req, res) => {
  const { userId } = req.params;
  
  // Validate userId is a valid UUID
  const uuidResult = z.string().uuid().safeParse(userId);
  if (!uuidResult.success) {
    return res.status(400).json({ error: 'Invalid user ID format' });
  }
  
  try {
    // Get user info
    const userResult = await pool.query('SELECT id, email, created_at FROM users WHERE id = $1', [userId]);
    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    const user = userResult.rows[0];
    
    // Get inventory statistics
    const inventoryStats = await pool.query(
      `SELECT 
        COUNT(*) as total_items,
        COALESCE(SUM(quantity), 0) as total_cards,
        COUNT(DISTINCT folder) as folder_count
       FROM inventory 
       WHERE user_id = $1`,
      [userId]
    );
    
    // Get deck count
    const deckStats = await pool.query(
      `SELECT COUNT(*) as deck_count 
       FROM decks 
       WHERE user_id = $1 AND (is_deck_instance = FALSE OR is_deck_instance IS NULL)`,
      [userId]
    );
    
    res.json({
      user: {
        id: user.id,
        email: user.email,
        createdAt: user.created_at
      },
      stats: {
        inventoryItems: parseInt(inventoryStats.rows[0].total_items) || 0,
        totalCards: parseInt(inventoryStats.rows[0].total_cards) || 0,
        folders: parseInt(inventoryStats.rows[0].folder_count) || 0,
        decks: parseInt(deckStats.rows[0].deck_count) || 0
      }
    });
  } catch (error) {
    console.error('[AI-API] Error fetching user:', error.message);
    res.status(500).json({ error: 'Failed to fetch user data' });
  }
});

export default router;
